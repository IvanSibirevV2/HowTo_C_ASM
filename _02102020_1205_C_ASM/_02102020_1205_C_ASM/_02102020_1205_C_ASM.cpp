// _02102020_1205_C_ASM.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//Этот пример посвящен работе с указателями

#include <iostream>
////////////////////////////////////////////////////////////////////////////////////
#include<windows.h>
#define __Set_TimeTestX 100000000
#define __Set_TestTimeStart double TickStart = GetTickCount(); for(int i=0;i<__Set_TimeTestX;i++)
#define __Set_TestTimeStop double TickFinish = GetTickCount();std::cout << "_TimeTest=" << TickFinish-TickStart << std::endl;
////////////////////////////////////////////////////////////////////////////////////
int main()
{
    /*Тест1*/if (false)
    {//Быстрый пример обмена значениями с использованием указателя...
        int x = 10;int y = 11;
        //<[Адрес в памяти;значение в пямяти]>
        std::cout << "<&x;x>=<" << &x << ";" << x << ">" << std::endl;
        std::cout << "<&y;y>=<" << &y << ";" << y << ">" << std::endl;
        //Указатель, как он рабтает
        int* yy = &y;//Этот код эквивалентен следующей ассемблерной вставке
        __asm
        {//Получение адреса переменной y
            lea eax, [y]//...=&y
            mov dword ptr[yy], eax//int* yy = ...
        }
        std::cout << "<&yy;yy>=<" << &yy << ";" << yy << ">" << std::endl;
        _asm
        {
            xor eax, eax
            xor ebx, ebx
            mov         eax, dword ptr[x]
            mov         ecx, dword ptr[yy]
            mov         ebx, dword ptr[ecx]
            mov          dword ptr[x], ebx
            mov          dword ptr[ecx], eax
        }
        std::cout << "<&x;x>=<" << &x << ";" << x << ">" << std::endl;
        std::cout << "<&y;y>=<" << &y << ";" << y << ">" << std::endl;
    }
    /*Test2*/else if (!false)
    {// Чуть более оптимальный вариант
        int x = 10;int y = 11;
        std::cout << "<&x;x>=<" << &x << ";" << x << ">" << std::endl;
        std::cout << "<&y;y>=<" << &y << ";" << y << ">" << std::endl;
        _asm
        {
            //Человеческая очистка
            xor eax, eax
            xor ebx, ebx
            //Получение значения x
            mov eax, [x]
            //Получение указателя
            lea ebx, [y]
            //Обмен значениями
            XCHG eax, [ebx]
            mov x, eax
        }
        std::cout << "<&x;x>=<" << &x << ";" << x << ">" << std::endl;
        std::cout << "<&y;y>=<" << &y << ";" << y << ">" << std::endl;
    }
    else if (false){}
    //////////////////////////////////////////////////////////////////////////////////////////
    //Теперь тесты производительности
    //////////////////////////////////////////////////////////////////////////////////////////
    //Забегая в перед, скажем, что МакросоФаговский <<mov eax, dword ptr[x]>>
    //Работает быстрее, чем все что может быть написано на  классических командах mov
    //По этому каждый чих оптимизируйте до дондышка...
    //////////////////////////////////////////////////////////////////////////////////////////
    /*Тест1*/
    {
        int x = 10;int y = 11;int* yy = &y;
        __Set_TestTimeStart
        _asm
        {
            xor eax, eax
            xor ebx, ebx
            mov eax, dword ptr[x]
            mov         ecx, dword ptr[yy]
            mov         ebx, dword ptr[ecx]
            mov          dword ptr[x], ebx
            mov          dword ptr[ecx], eax
        }
        __Set_TestTimeStop
    }
    /*Test2*/
    {
        //Даже если попытаетесь упростить, лучше чем индекс 1000 не получите...//Это косяк
        int x = 10;int y = 11;
        __Set_TestTimeStart
        _asm
        {
            xor eax, eax
            xor ebx, ebx
            mov eax, dword ptr[x]
            
            lea ebx, [y]
            
            XCHG eax, dword ptr[ebx]
            mov x, eax
        }
        __Set_TestTimeStop
    }
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
