<!DOCTYPE html>
<!-- saved from url=(0045)http://natalia.appmat.ru/c&c++/assembler.html -->
<html lang="ru-RU"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title> Программирование на языке ассемблера  </title>
  <link rel="stylesheet" href="./Программирование на языке ассемблера_files/stili.css" type="text/css">
  <link rel="shortcut icon" href="http://natalia.appmat.ru/c&amp;c++/Images/icon.gif">
</head>


<body>

<header> Программирование на языке ассемблера </header>

<p>
В данной части курса рассматриваются основы программирования на языке ассемблера для архитектуры Win32.

</p><p>
Все процессы в машине на самом низком, аппаратном уровне приводятся в действие только командами (инструкциями) машинного языка. <i>Язык ассемблера – это символическое представление машинного языка</i>. Ассемблер позволяет писать короткие и быстрые программы. Однако этот процесс чрезвычайно трудоёмкий. Для написания максимально эффективной программы необходимо хорошее знание особенностей команд языка ассемблера, внимание и аккуратность. Поэтому реально на языке ассемблера пишутся в основном программы, которые должны обеспечить эффективную работу с аппаратной частью. Также на языке ассемблера пишутся критичные по времени выполнения или расходованию памяти участки программы. Впоследствии они оформляются в виде подпрограмм и совмещаются с кодом на языке высокого уровня.

</p><section id="a1">
<h1>1. Регистры</h1>

<p>
<i>Регистры</i> – это специальные ячейки памяти, расположенные непосредственно в процессоре. Работа с регистрами выполняется намного быстрее, чем с ячейками оперативной памяти, поэтому регистры активно используются как в программах на языке ассемблера, так и компиляторами языков высокого уровня.

</p><p>
Регистры можно разделить на <i>регистры общего назначения</i>, <i>указатель команд</i>, <i>регистр флагов и сегментные регистры</i>.


</p><h2 id="a1_1">1.1. Регистры общего назначения</h2>

<p>
К регистрам общего назначения относится группа из 8 регистров, которые можно использовать в программе на языке ассемблера. Все регистры имеют размер 32 бита и могут быть разделены на 2 или более частей.

</p><p class="img"><img class="asm" src="./Программирование на языке ассемблера_files/Registers.gif" alt="Регистры общего назначения">

</p><p>
Как видно из рисунка, регистры ESI, EDI, ESP и EBP позволяют обращаться к младшим 16 битам по именам SI, DI, SP и BP соответственно, а регистры EAX, EBX, ECX и EDX позволяют обращаться как к младшим 16 битам (по именам AX, BX, CX и DX), так и к двум младшим байтам по отдельности (по именам AH/AL, BH/BL, CH/CL и DH/DL).

</p><p>
Названия регистров происходят от их назначения:

</p><ul>
  <li> <b>EAX/AX/AH/AL</b> (<i>accumulator register</i>) – аккумулятор;
  </li><li> <b>EBX/BX/BH/BL</b> (<i>base register</i>) –регистр базы;
  </li><li> <b>ECX/CX/CH/CL</b> (<i>counter register</i>) – счётчик;
  </li><li> <b>EDX/DX/DH/DL</b> (<i>data register</i>) – регистр данных;
  </li><li> <b>ESI/SI</b> (<i>source index register</i>) – индекс источника;
  </li><li> <b>EDI/DI</b> (<i>destination index register</i>) – индекс приёмника (получателя);
  </li><li> <b>ESP/SP</b> (<i>stack pointer register</i>) – регистр указателя стека;
  </li><li> <b>EBP/BP</b> (<i>base pointer register</i>) – регистр указателя базы кадра стека.
</li></ul>

<p>
Несмотря на существующую специализацию, все регистры можно использовать в любых машинных операциях. Однако надо учитывать тот факт, что некоторые команды работают только с определёнными регистрами. Например, команды умножения и деления используют регистры EAX и EDX для хранения исходных данных и результата операции. Команды управления циклом используют регистр ECX в качестве счётчика цикла.

</p><p>
Ещё один нюанс состоит в использовании регистров в качестве <i>базы</i>, т.е. хранилища адреса оперативной памяти. В качестве регистров базы можно использовать любые регистры, но желательно использовать регистры EBX, ESI, EDI или EBP. В этом случае размер машинной команды обычно бывает меньше.

</p><p>
К сожалению, количество регистров катастрофически мало, и зачастую бывает трудно подобрать способ их оптимального использования.


</p><h2 id="a1_2">1.2. Указатель команд</h2>

<p>
Регистр EIP (<i>указатель команд</i>) содержит смещение следующей подлежащей выполнению команды. Этот регистр непосредственно недоступен программисту, но загрузка и изменение его значения производятся различными командами управления, к которым относятся команды условных и безусловных переходов, вызова процедур и возврата из процедур.


</p><h2 id="a1_3">1.3. Регистр флагов</h2>

<p>
<i>Флаг</i> – это бит, принимающий значение 1 («флаг установлен»), если выполнено некоторое условие, и значение 0 («флаг сброшен») в противном случае. Процессор имеет <i>регистр флагов</i>, содержащий набор флагов, отражающий текущее состояние процессора.

</p><table>
<tbody><tr>
  <th> № бита
  </th><th> Обозначение
  </th><th> Название
  </th><th> Описание
  </th><th> Тип флага

</th></tr><tr>
  <td colspan="5" style="text-align: center; font-style: italic; font-weight: bold">FLAGS

</td></tr><tr>
  <td> 0
  </td><td> CF
  </td><td> Carry Flag
  </td><td> Флаг переноса
  </td><td> Состояние

</td></tr><tr>
  <td> 1
  </td><td colspan="2" style="background-color: #cccccc"> 1
  </td><td> Зарезервирован
  </td><td> 

</td></tr><tr>
  <td> 2
  </td><td> PF
  </td><td> Parity Flag
  </td><td> Флаг чётности
  </td><td> Состояние

</td></tr><tr>
  <td> 3
  </td><td colspan="2" style="background-color: #cccccc"> 0
  </td><td> Зарезервирован
  </td><td> 

</td></tr><tr>
  <td> 4
  </td><td> AF
  </td><td> Auxiliary Carry Flag
  </td><td> Вспомогательный флаг переноса
  </td><td> Состояние

</td></tr><tr>
  <td> 5
  </td><td colspan="2" style="background-color: #cccccc"> 0
  </td><td> Зарезервирован
  </td><td>

</td></tr><tr>
  <td> 6
  </td><td> ZF
  </td><td> Zero Flag
  </td><td> Флаг нуля
  </td><td> Состояние

</td></tr><tr>
  <td> 7
  </td><td> SF
  </td><td> Sign Flag
  </td><td> Флаг знака
  </td><td> Состояние

</td></tr><tr>
  <td> 8
  </td><td> TF
  </td><td> Trap Flag
  </td><td> Флаг трассировки
  </td><td> Системный

</td></tr><tr>
  <td> 9
  </td><td> IF
  </td><td> Interrupt Enable Flag
  </td><td> Флаг разрешения прерываний
  </td><td> Системный

</td></tr><tr>
  <td> 10
  </td><td> DF
  </td><td> Direction Flag
  </td><td> Флаг направления
  </td><td> Управляющий

</td></tr><tr>
  <td> 11
  </td><td> OF
  </td><td> Overflow Flag
  </td><td> Флаг переполнения
  </td><td> Состояние

</td></tr><tr>
  <td> 12
  </td><td rowspan="2"> IOPL
  </td><td rowspan="2"> I/O Privilege Level
  </td><td rowspan="2"> Уровень приоритета ввода-вывода
  </td><td rowspan="2"> Системный

</td></tr><tr>
  <td> 13

</td></tr><tr>
  <td> 14
  </td><td> NT
  </td><td> Nested Task
  </td><td> Флаг вложенности задач
  </td><td> Системный

</td></tr><tr>
  <td> 15
  </td><td colspan="2" style="background-color: #cccccc"> 0
  </td><td> Зарезервирован
  </td><td>

</td></tr><tr>
  <td colspan="5" style="text-align: center; font-style: italic; font-weight: bold">EFLAGS

</td></tr><tr>
  <td> 16
  </td><td> RF
  </td><td> Resume Flag
  </td><td> Флаг возобновления
  </td><td> Системный

</td></tr><tr>
  <td> 17
  </td><td> VM
  </td><td> Virtual-8086 Mode
  </td><td> Режим виртуального процессора 8086
  </td><td> Системный

</td></tr><tr>
  <td> 18
  </td><td> AC
  </td><td> Alignment Check
  </td><td> Проверка выравнивания
  </td><td> Системный

</td></tr><tr>
  <td> 19
  </td><td> VIF
  </td><td> Virtual Interrupt Flag
  </td><td> Виртуальный флаг разрешения прерывания
  </td><td> Системный

</td></tr><tr>
  <td> 20
  </td><td> VIP
  </td><td> Virtual Interrupt Pending
  </td><td> Ожидающее виртуальное прерывание
  </td><td> Системный

</td></tr><tr>
  <td> 21
  </td><td> ID
  </td><td> ID Flag
  </td><td> Проверка на доступность инструкции CPUID
  </td><td> Системный

</td></tr><tr>
  <td> 22
  </td><td colspan="2" rowspan="3" style="background-color: #cccccc">
  </td><td rowspan="3"> Зарезервированы
  </td><td rowspan="3">

</td></tr><tr>
  <td> <b>...</b>

</td></tr><tr>
  <td> 31
</td></tr></tbody></table>


<p>
Значение флагов CF, DF и IF можно изменять напрямую в регистре флагов с помощью специальных инструкций (например, <span class="mnemo">CLD</span> для сброса флага направления), но нет инструкций, которые позволяют обратиться к регистру флагов как к обычному регистру. Однако можно сохранять регистр флагов в стек или регистр AH и восстанавливать регистр флагов из них с помощью инструкций <span class="mnemo">LAHF</span>, <span class="mnemo">SAHF</span>, <span class="mnemo">PUSHF</span>, <span class="mnemo">PUSHFD</span>, <span class="mnemo">POPF</span> и <span class="mnemo">POPFD</span>.


</p><h3 id="a1_3_1">1.3.1. Флаги состояния</h3>

<p>
Флаги состояния (биты 0, 2, 4, 6, 7 и 11) отражают результат выполнения арифметических инструкций, таких как <span class="mnemo">ADD</span>, <span class="mnemo">SUB</span>, <span class="mnemo">MUL</span>, <span class="mnemo">DIV</span>.

</p><ul>
  <li> <i>Флаг переноса</i> CF устанавливается при переносе из старшего значащего бита/заёме в старший значащий бит и показывает наличие переполнения в беззнаковой целочисленной арифметике. Также используется в длинной арифметике.
  </li><li> <i>Флаг чётности</i> PF устанавливается, если младший значащий байт результата содержит чётное число единичных битов. Изначально этот флаг был ориентирован на использование в коммуникационных программах: при передаче данных по линиям связи для контроля мог также передаваться бит чётности и инструкции для проверки флага чётности облегчали проверку целостности данных.
  </li><li> <i>Вспомогательный флаг переноса</i> AF устанавливается при переносе из бита 3-го результата/заёме в 3-ий бит результата. Этот флаг ориентирован на использование в двоично-десятичной (binary coded decimal, BCD) арифметике.
  </li><li> <i>Флаг нуля</i> ZF устанавливается, если результат равен нулю.
  </li><li> <i>Флаг знака</i> SF равен значению старшего значащего бита результата, который является знаковым битом в знаковой арифметике.
  </li><li> <i>Флаг переполнения</i> OF устанавливается, если целочисленный результат слишком длинный для размещения в целевом операнде (регистре или ячейке памяти). Этот флаг показывает наличие переполнения в знаковой целочисленной арифметике.
</li></ul>

<p>
Из перечисленных флагов только флаг CF можно изменять напрямую с помощью инструкций <span class="mnemo">STC</span>, <span class="mnemo">CLC</span> и <span class="mnemo">CMC</span>.

</p><p>
Флаги состояния позволяют одной и той же арифметической инструкции выдавать результат трёх различных типов: беззнаковое, знаковое и двоично-десятичное (BCD) целое число. Если результат считать беззнаковым числом, то флаг CF показывает условие переполнения (перенос или заём), для знакового результата перенос или заём показывает флаг OF, а для BCD-результата перенос/заём показывает флаг AF. Флаг SF отражает знак знакового результата, флаг ZF отражает и беззнаковый, и знаковый нулевой результат.

</p><p>
В длинной целочисленной арифметике флаг CF используется совместно с инструкциями сложения с переносом (<span class="mnemo">ADC</span>) и вычитания с заёмом (<span class="mnemo">SBB</span>) для распространения переноса или заёма из одного вычисляемого разряда длинного числа в другой.

</p><p>
Инструкции условного перехода <span class="mnemo">Jcc</span> (переход по условию <span class="mnemo">cc</span>), <span class="mnemo">SETcc</span> (установить значение байта-результата в зависимости от условия <span class="mnemo">cc</span>), <span class="mnemo">LOOPcc</span> (организация цикла) и <span class="mnemo">CMOVcc</span> (условное копирование) используют один или несколько флагов состояния для проверки условия. Например, инструкция перехода <span class="mnemo">JLE</span> (<i>jump if less or equal</i> – переход, если «меньше или равно») проверяет условие «<span style="white-space: nowrap">ZF&nbsp;=&nbsp;1</span> или <span style="white-space: nowrap">SF&nbsp;≠&nbsp;OF</span>».

</p><p>
Флаг PF был введён для совместимости с другими микропроцессорными архитектурами и по прямому назначению используется редко. Более распространено его использование совместно с остальными флагами состояния в арифметике с плавающей запятой: инструкции сравнения (<span class="mnemo">FCOM</span>, <span class="mnemo">FCOMP</span> и т. п.) в математическом сопроцессоре устанавливают в нём флаги-условия C0, C1, C2 и C3, и эти флаги можно скопировать в регистр флагов. Для этого рекомендуется использовать инструкцию <span class="mnemo" style="white-space: nowrap">FSTSW&nbsp;&nbsp;AX</span> для сохранения слова состояния сопроцессора в регистре AX и инструкцию <span class="mnemo">SAHF</span> для последующего копирования содержимого регистра AH в младшие 8 битов регистра флагов, при этом C0 попадает во флаг CF, C2 – в PF, а C3 – в ZF. Флаг C2 устанавливается, например, в случае несравнимых аргументов (NaN или неподдерживаемый формат) в инструкции сравнения <span class="mnemo">FUCOM</span>.


</p><h3 id="a1_3_2">1.3.2. Управляющий флаг</h3>

<p>
<i>Флаг направления</i> DF (бит 10 в регистре флагов) управляет строковыми инструкциями (<span class="mnemo">MOVS</span>, <span class="mnemo">CMPS</span>, <span class="mnemo">SCAS</span>, <span class="mnemo">LODS</span> и <span class="mnemo">STOS</span>) – установка флага заставляет уменьшать адреса (обрабатывать строки от старших адресов к младшим), обнуление заставляет увеличивать адреса. Инструкции <span class="mnemo">STD</span> и <span class="mnemo">CLD</span> соответственно устанавливают и сбрасывают флаг DF.


</p><h3 id="a1_3_3">1.3.3. Системные флаги и поле IOPL</h3>

<p>
Системные флаги и поле IOPL управляют операционной средой и не предназначены для использования в прикладных программах.

</p><ul>
  <li> <i>Флаг разрешения прерываний</i> IF – обнуление этого флага запрещает отвечать на маскируемые запросы на прерывание.
  </li><li> <i>Флаг трассировки</i> TF – установка этого флага разрешает пошаговый режим отладки, когда после каждой выполненной инструкции происходит прерывание программы и вызов специального обработчика прерывания.
  </li><li> Поле IOPL показывает уровень приоритета ввода-вывода исполняемой программы или задачи: чтобы программа или задача могла выполнять инструкции ввода-вывода или менять флаг IF, её текущий уровень приоритета (CPL) должен быть <span style="white-space: nowrap">≤ IOPL</span>.
  </li><li> <i>Флаг вложенности задач</i> NT – этот флаг устанавливается, когда текущая задача «вложена» в другую, прерванную задачу, и сегмент состояния TSS текущей задачи обеспечивает обратную связь с TSS предыдущей задачи. Флаг NT проверяется инструкцией IRET для определения типа возврата – межзадачного или внутризадачного.
  </li><li> <i>Флаг возобновления</i> RF используется для маскирования ошибок отладки.
  </li><li> VM – установка этого флага в защищённом режиме вызывает переключение в режим виртуального 8086.
  </li><li> <i>Флаг проверки выравнивания</i> AC – установка этого флага вместе с битом AM в регистре CR0 включает контроль выравнивания операндов при обращениях к памяти: обращение к невыравненному операнду вызывает исключительную ситуацию.
  </li><li> VIF – виртуальная копия флага IF; используется совместно с флагом VIP.
  </li><li> VIP – устанавливается для указания наличия отложенного прерывания.
  </li><li> ID – возможность программно изменить этот флаг в регистре флагов указывает на поддержку инструкции CPUID.
</li></ul>


<h2 id="a1_4">1.4. Сегментные регистры</h2>

<p>
Процессор имеет 6 так называемых <i>сегментных</i> регистров: CS, DS, SS, ES, FS и GS. Их существование обусловлено спецификой организации и использования оперативной памяти.

</p><p>
16-битные регистры могли адресовать только 64&nbsp;Кб оперативной памяти, что явно недостаточно для более или менее приличной программы. Поэтому память программе выделялась в виде нескольких <i>сегментов</i>, которые имели размер 64&nbsp;Кб. При этом <i>абсолютные</i> адреса были 20-битными, что позволяло адресовать уже 1&nbsp;Мб оперативной памяти. Возникает вопрос – как имея 16-битные регистры хранить 20-битные адреса? Для решения этой задачи адрес разбивался на <i>базу</i> и <i>смещение</i>. База – это адрес начала сегмента, а смещение – это номер байта внутри сегмента. На адрес начала сегмента накладывалось ограничение – он должен был быть кратен 16. При этом последние 4 бита были равны 0 и не хранились, а подразумевались. Таким образом, получались две 16-битные части адреса. Для получения абсолютного адреса к базе добавлялись четыре нулевых бита, и полученное значение складывалось со смещением.

</p><p>
Сегментные регистры использовались для хранения адреса начала <i>сегмента кода</i> (CS – code segment), <i>сегмента данных</i> (DS – data segment) и <i>сегмента стека</i> (SS – stack segment). Регистры ES, FS и GS были добавлены позже. Существовало несколько моделей памяти, каждая из которых подразумевала выделение программе одного или нескольких сегментов кода и одного или нескольких сегментов данных: <i>tiny</i>, <i>small</i>, <i>medium</i>, <i>compact</i>, <i>large</i> и <i>huge</i>. Для команд языка ассемблера существовали определённые соглашения: адреса перехода сегментировались по регистру CS, обращения к данным сегментировались по регистру DS, а обращения к стеку – по регистру SS. Если программе выделялось несколько сегментов для кода или данных, то приходилось менять значения в регистрах CS и DS для обращения к другому сегменту. Существовали так называемые «ближние» и «дальние» переходы. Если команда, на которую надо совершить переход, находилась в том же сегменте, то для перехода достаточно было изменить только значение регистра IP. Такой переход назывался <i>ближним</i>. Если же команда, на которую надо совершить переход, находилась в другом сегменте, то для перехода необходимо было изменить как значение регистра CS, так и значение регистра IP. Такой переход назывался <i>дальним</i> и осуществлялся дольше.

</p><p>
32-битные регистры позволяют адресовать 4&nbsp;Гб памяти, что уже достаточно для любой программы. Каждую Win32-программу Windows запускает в отдельном виртуальном пространстве. Это означает, что каждая Win32-программа будет иметь 4-х гигабайтовое адресное пространство, но вовсе не означает, что каждая программа имеет 4&nbsp;Гб физической памяти, а только то, что программа может обращаться по любому адресу в этих пределах. А Windows сделает все необходимое, чтобы память, к которой программа обращается, «существовала». Конечно, программа должна придерживаться правил, установленных Windows, иначе возникает ошибка General Protection Fault.

</p><p>
Под архитектурой Win32 отпала необходимость в разделении адреса на базу и смещение, и необходимость в моделях памяти. На 32-битной архитектуре существует только одна модель памяти – <i>flat</i> (<i>сплошная</i> или <i>плоская</i>). Сегментные регистры остались, но используются по-другому<a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#nota1"><sup>1</sup></a>. Раньше необходимо было связывать отдельные части программы с тем или иным сегментным регистром и сохранять/восстанавливать регистр DS при переходе к другому сегменту данных или явно сегментировать данные по другому регистру. При 32-битной архитектуре необходимость в этом отпала, и в простейшем случае про сегментные регистры можно забыть.


</p><h2 id="a1_5">1.5. Использование стека</h2>

<p>
Каждая программа имеет область памяти, называемую <i>стеком</i>. Стек используется для передачи параметров в процедуры и для хранения локальных данных процедур. Как известно, <i>стек</i> – это область памяти, при работе с которой необходимо соблюдать определённые правила, а именно: данные, которые попали в стек первыми, извлекаются оттуда последними. С другой стороны, если программе выделена некоторая память, то нет никаких физических ограничений на чтение и запись. Как же совмещаются два этих противоречивых принципа?

</p><p class="img"><img class="asm" src="./Программирование на языке ассемблера_files/Stack.gif" alt="Использование стека">

</p><p>
Пусть у нас есть функция <i>f1</i>, которая вызывает функцию <i>f2</i>, а функция <i>f2</i>, в свою очередь, вызывает функцию <i>f3</i>. При вызове функции <i>f1</i> ей отводится определённое место в стеке под локальные данные. Это место отводится путём вычитания из регистра ESP значения, равного размеру требуемой памяти. Минимальный размер отводимой памяти равен 4 байтам, т.е. даже если процедуре требуется 1 байт, она должна занять 4 байта.

</p><p>
Функция <i>f1</i> выполняет некоторые действия, после чего вызывает функцию <i>f2</i>. Функция&nbsp;<i>f2</i> также отводит себе место в стеке, вычитая некоторое значение из регистра ESP. При этом локальные данные функций <i>f1</i> и <i>f2</i> размещаются в разных областях памяти. Далее функция&nbsp;<i>f2</i> вызывает функцию <i>f3</i>, которая также отводит себе место в стеке. Функция <i>f3</i> других функций не вызывает и при завершении работы должна освободить место в стеке, прибавив к регистру ESP значение, которые было вычтено при вызове функции. Если функция <i>f3</i> не восстановит значение регистра ESP, то функция <i>f2</i>, продолжив работу, будет обращаться не к своим данным, т.к. она ищет их, основываясь на значении регистра ESP. Аналогично функция <i>f2</i> должна при выходе восстановить значение регистра ESP, которое было до её вызова.

</p><p>
Таким образом, на уровне процедур необходимо соблюдать правила работы со стеком – процедура, которая заняла место в стеке последней, должна освобождать его первой. При несоблюдении этого правила, программа будет работать некорректно. Но каждая процедура может обращаться к своей области стека произвольным образом. Если бы мы были вынуждены соблюдать правила работы со стеком внутри каждой процедуры, пришлось бы перекладывать данные из стека в другую область памяти, а это было бы крайне неудобно и чрезвычайно замедлило бы выполнение программы.

</p><p>
Каждая программа имеет область данных, где размещаются глобальные переменные. Почему же локальные данные хранятся именно в стеке? Это делается для уменьшения объёма памяти занимаемого программой. Если программа будет <i>последовательно</i> вызывать несколько процедур, то в каждый момент времени будет отведено место только под данные одной процедуры, т.к. стек занимается и освобождается. Область данных существует всё время работы программы. Если бы локальные данные размещались в области данных, пришлось бы отводить место под локальные данные для <i>всех</i> процедур программы.

</p><p>
Локальные данные автоматически не инициализируются. Если в вышеприведённом примере функция <i>f2</i> после функции <i>f3</i> вызовет функцию <i>f4</i>, то функция <i>f4</i> займёт в стеке место, которое до этого было занято функцией <i>f3</i>, таким образом, функции <i>f4</i> «в наследство» достанутся данные функции <i>f3</i>. Поэтому каждая процедура обязательно должна заботиться об инициализации своих локальных данных.

</p></section>


<section id="a2">

<h1>2. Основные понятия языка ассемблера</h1>

<h2 id="a2_1">2.1. Идентификаторы</h2>

<p>
Понятие идентификатора в языке ассемблера ничем не отличается от понятия идентификатора в других языках. Можно использовать латинские буквы, цифры и знаки <code>_&nbsp;.&nbsp;?&nbsp;@&nbsp;$</code>, причём точка может быть только первым символом идентификатора. Большие и маленькие буквы считаются эквивалентными.


</p><h2 id="a2_2">2.2. Целые числа</h2>

<p>
В программе на языке ассемблера целые числа могут быть записаны в двоичной, восьмеричной, десятичной и шестнадцатеричной системах счисления. Для задания системы счисления в конце числа ставится буква <code>b</code>, <code>o/q</code>, <code>d</code> или <code>h</code> соответственно. Шестнадцатеричные числа, которые начинаются с «буквенной» цифры, должны предваряться нулём, иначе компилятор не сможет отличить число от идентификатора. Примеры чисел см. в <a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#a2_6">разделе 2.6</a>.


</p><h2 id="a2_3">2.3. Символьные данные</h2>

<p>
Символы и строки в языке ассемблера могут заключаться в апострофы или двойные кавычки. Если в качестве символа или внутри строки надо указать апостроф или кавычку, то делается это следующим образом: если символ или строка заключены в апострофы, то апостроф надо удваивать, а кавычку удваивать не надо, и наоборот, если символ или строка заключены в двойные кавычки, то надо удваивать кавычку и не надо удваивать апостроф. Все следующие примеры корректны и эквивалентны: <code>'don''t'</code>, <code>'don"t'</code>, <code>"don't"</code>, <code>"don""t"</code>.


</p><h2 id="a2_4">2.4. Комментарии</h2>

<p>
Комментарии в языке ассемблера начинаются с символа «точка с запятой» и могут начинаться как в начале строки, так и после команды.


</p><h2 id="a2_5">2.5. Директива эквивалентности</h2>

<p>
Директива эквивалентности позволяет описывать константы:

</p><p class="code">
<code>&lt;имя&gt; <span class="mnemo">EQU</span> &lt;операнд&gt;
</code>

</p><p>
Все вхождения <i>имени</i> заменяются <i>операндом</i>. Операндом может быть константное выражение, строка, другое имя.


</p><h2 id="a2_6">2.6. Директивы определения данных</h2>

<p>
Языки высокого уровня обычно являются типизированными. Каждая переменная имеет тип, который накладывает ограничения на операции над переменной и на использование в одном выражении переменных разных типов. Кроме того, языки высокого уровня позволяют работать со сложными типами, таким как указатели, записи/структуры, классы, массивы, строки, множества и т.п.

</p><p>
Язык Паскаль имеет достаточно жёсткую структуру типов. Присваивания между переменными разных типов минимальны, над указателями определены только операции присваивания, взятия значения и получение адреса. Поддерживается много сложных типов.

</p><p>
Язык С, который создавался как высокоуровневая замена языку ассемблера, имеет гораздо менее жёсткую структуру типов. Все целочисленные типы совместимы, тип <i>char</i>, конечно, хранит символы, но также сопоставим с целыми типами, логический тип отсутствует в принципе (для языка С это именно так!), над указателями определены операции сложения и вычитания. Сложные типы, такие как массивы, строки и множества, не поддерживаются.

</p><p>
Что касается языка ассемблера, то тут вообще вряд ли можно говорить о какой-либо структуре типов. Команды языка ассемблера оперируют объектами, существующими в оперативной памяти, т.е. байтом и его производными (слово, двойное слово и т.д.). Символьный, логический тип? Какая глупость! Указатели? Вот тебе 4 байта и делай с ними, что хочешь. В итоге, конечно, и можно сделать, что хочешь, только предварительно стоит хорошо подумать, что из этого получится.

</p><p>
Соответственно, в языке ассемблера существует 5 (!) директив для определения данных:

</p><ul>
  <li> <span class="mnemo">DB</span> (<i>define byte</i>) – определяет переменную размером в 1 байт;
  </li><li> <span class="mnemo">DW</span> (<i>define word</i>) – определяет переменную размеров в 2 байта (слово);
  </li><li> <span class="mnemo">DD</span> (<i>define double word</i>) – определяет переменную размером в 4 байта (двойное слово);
  </li><li> <span class="mnemo">DQ</span> (<i>define quad word</i>) – определяет переменную размером в 8 байт (учетверённое слово);
  </li><li> <span class="mnemo">DT</span> (<i>define ten bytes</i>) – определяет переменную размером в 10 байт.
</li></ul>

<p>
Все директивы могут быть использованы как для объявления простых переменных, так и для объявления массивов. Хотя для определения строк, в принципе, можно использовать любую директиву, в связи с особенностями хранения данных в оперативной памяти лучше использовать директиву <span class="mnemo">DB</span>.

</p><p>
Синтаксис директив определения данных следующий:

</p><p class="code">
<code>&lt;имя&gt; <span class="mnemo">DB</span> &lt;операнд&gt; [, &lt;операнд&gt;]
&lt;имя&gt; <span class="mnemo">DW</span> &lt;операнд&gt; [, &lt;операнд&gt;]
&lt;имя&gt; <span class="mnemo">DD</span> &lt;операнд&gt; [, &lt;операнд&gt;]
&lt;имя&gt; <span class="mnemo">DQ</span> &lt;операнд&gt; [, &lt;операнд&gt;]
&lt;имя&gt; <span class="mnemo">DT</span> &lt;операнд&gt; [, &lt;операнд&gt;]
</code>

</p><p>
<i>Операнд</i> задаёт начальное значение переменной. В качестве операнда может использоваться число, символ или знак вопроса, с помощью которого определяются неинициализированные переменные.

</p><p>
Если в качестве операнда указывается строка или если указано несколько операндов через запятую, то память отводится под несколько переменных указанного типа, т.е. получается массив. При этом именованным оказывается только первый элемент, а доступ к остальным элементам массива осуществляется с помощью выражения <code>&lt;имя&gt;&nbsp;+&nbsp;&lt;смещение&gt;</code>.

</p><p>
Для того чтобы не указывать несколько раз одно и то же значение, при инициализации массивов можно использовать конструкцию повторения <span class="mnemo">DUP</span>.

</p><p class="code">
<code>a db 10011001b		; Определяем переменную размером 1 байт с начальным значением, заданным в двоичной системе счисления
b db '!'		; Определяем переменную в 1 байт, инициализируемую символом '!'
d db 'string',13,10	; Определяем массив из 8 байт
e db 'string',0		; Определяем строку из 7 байт, заканчивающую нулём
f dw 1235o		; Определяем переменную размером 2 байта с начальным значением, заданным в восьмеричной системе счисления
g dd -345d		; Определяем переменную размером 4 байта с начальным значением, заданным в десятичной системе счисления
h dd 0f1ah		; Определяем переменную размером 4 байта с начальным значением, заданным в шестнадцатеричной системе счисления
i dd ?			; Определяем неинициализированную переменную размером 4 байта
j dd 100 dup (0)	; Определяем массив из 100 двойных слов, инициализированных 0
k dq 10 dup (0, 1, 2)	; Определяем массив из 30 учетверённых слов, инициализированный повторяющимися значениями 0, 1 и 2
l dd 100 dup (?)	; Определяем массив из 100 неинициализированных двойных слов
</code>

</p><p>
К переменным можно применить две операции – <code>offset</code> и <code>type</code>. Первая определяет адрес переменной, а вторая – размер переменной. Однако размер переменной определяется по директиве, и даже если с директивой, например, <span class="mnemo">DD</span> определён массив из нескольких элементов, размер всё равно будет равен 4.


</p><h2 id="a2_7">2.7. Команды</h2>

<p>
<i>Команды языка ассемблера</i> – это символьная форма записи машинных команд. Команды имеют следующий синтаксис:

</p><p class="code">
<code>[&lt;метка&gt;:] &lt;мнемокод&gt; [&lt;операнды&gt;] [;&lt;комментарий&gt;]
</code>

</p><p>
<i>Метка</i> – это имя. Метка обязательно должна отделяться двоеточием, но может размещаться отдельно, в строке, предшествующей остальной части команды.

</p><p>
Метки нужны для ссылок на команды из других мест, например, в командах перехода. Компилятор языка ассемблера заменяет метки адресами команд.

</p><p>
<i>Мнемокод</i> – это служебное слово, указывающее операцию, которая должна быть выполнена. Язык ассемблера использует не цифровые коды операций, а мнемокоды, которые легче запоминаются. Мнемокод является обязательной частью команды.

</p><p>
<i>Операнды</i> команды, если они есть, отделяются друг от друга запятыми.
</p><h2 id="a2_8">2.8. Операнды команд</h2>

<p>
В качестве операндов команд языка ассемблера могут использоваться:

</p><ul>
  <li> регистры, обращение к которым осуществляется по именам;
  </li><li> непосредственные операнды – константы, записываемые непосредственно в команде;
  </li><li> ячейки памяти – в команде записывается адрес нужной ячейки.
</li></ul>

<p>
Для задания адреса существуют следующие возможности.

</p><ul>
  <li> <i>Имя переменной</i>, по сути, является адресом этой переменной. Встретив имя переменной в операндах команды, компилятор понимает, что нужно обратиться к оперативной памяти по определённому адресу. Обычно адрес в команде указывается в квадратных скобках, но имя переменной является исключением и может быть указано как в квадратных скобках, так и без них. Например, для обращения к переменной <var>x</var> в команде можно указать <code>x</code> или <code>[x]</code>.
  </li><li> Если переменная была объявлена как массив, то к элементу массива можно обратиться, указав <i>имя</i> и <i>смещение</i>. Для этого существует ряд синтаксических форм, например: <code>&lt;имя&gt;[&lt;смещение&gt;]</code> и <code>[&lt;имя&gt;&nbsp;+&nbsp;&lt;смещение&gt;]</code> (см. <a href="http://natalia.appmat.ru/c&amp;c++/a5">раздел 5</a>). Однако следует понимать, что смещение – это вовсе не индекс элемента массива. Индекс элемента массива – это его номер, и этот номер не зависит от размера самого элемента. Смещение же задаётся в байтах, и при задании смещения программист сам должен учитывать размер элемента массива.
  </li><li> Адрес ячейки памяти может храниться в регистре. Для обращения к памяти по адресу, хранящемуся в регистре, в команде указывается имя регистра в квадратных скобках, например: <code>[ebx]</code>. Как уже говорилось, в качестве регистров базы рекомендуется использовать регистры EBX, ESI, EDI и EBP.
  </li><li> Адрес может быть вычислен по определённой формуле. Для этого в квадратных скобках можно указывать достаточно сложные выражения, например, <code>[ebx + ecx]</code> или <code>[ebx + 4 * ecx]</code>.
</li></ul>

<p>
В описаниях команд языка ассемблера для обозначения возможных операндов используют сокращения, состоящие из буквы <i>r</i> (для регистров), <i>m</i> (для памяти) или <i>i</i> (для непосредственного операнда) и числа 8, 16 или 32, указывающего размер операнда. Например:

</p><p class="code">
<code>add r8/r16/r32, r8/r16/r32	; Сложение регистра с регистром
add r8/r16/r32, m8/m16/m32	; Сложение регистра с ячейкой памяти
add r8/r16/r32, i8/i16/i32	; Сложение регистра с непосредственным операндом
add m8/m16/m32, r8/r16/r32	; Сложение ячейки памяти с регистром
add m8/m16/m32, i8/i16/i32	; Сложение ячейки памяти с непосредственным операндом
</code>

</p><p>
Команды языка ассемблера обычно имеют 1 или 2 операнда, или не имеют операндов вообще. Во многих, хотя не во всех, случаях операнды (если их два) должны иметь одинаковый размер. Команды языка ассемблера обычно не работают с двумя ячейками памяти.

</p></section>



<section id="a3">

<h1>3. Пересылка и арифметические команды</h1>

<h2 id="a3_1">3.1. Команды пересылки и обмена</h2>

<p>
Одна из основных команд языка ассемблер – это команда <i>пересылки</i>. С её помощью можно записать в регистр значение другого регистра, константу или значение ячейки памяти, а также можно записать в ячейку памяти значение регистра или константу. Команда имеет следующий синтаксис:

</p><p class="code">
<code><span class="mnemo">MOV</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;
</code>

</p><p>
По команде <span class="mnemo">MOV</span> значение второго операнда записывается в первый операнд. Операнды должны иметь одинаковый размер. Команда не меняет флаги.

</p><p class="code">
<code>mov   eax, ebx		; Пересылаем значение регистра EBX в регистр EAX
mov   eax, 0ffffh	; Записываем в регистр EAX шестнадцатеричное значение ffff
mov   x, 0		; Записываем в переменную x значение 0
mov   eax, x		; Переслать значение из одной ячейки памяти в другую нельзя.
mov   y, eax		; Но можно использовать две команды <span class="mnemo">MOV</span>.
</code>

</p><p>
На самом деле процессор имеет много команд пересылки – код команды зависит от того, куда и откуда пересылаются данные. Но компилятор языка ассемблера сам выбирает нужный код в зависимости от операндов, так что, с точки зрения программиста, команда пересылки только одна.

</p><p>
Для перестановки двух величин используется команда <i>обмена</i>:

</p><p class="code">
<code><span class="mnemo">XCHG</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;
</code>

</p><p>
Каждый из операндов может быть регистром или ячейкой памяти. Однако переставить содержимое двух регистров можно, а двух ячеек памяти – нет. Операнды должны иметь одинаковый размер. Команда не меняет флаги.


</p><h2 id="a3_2">3.2. Оператор указания типа</h2>

<p>
Как было сказано, операнды команды <span class="mnemo">MOV</span> должны иметь одинаковый размер. В некоторых случаях компилятор может определить размер операнда. Например, регистр EAX имеет размер 32 бита, а регистр DX – 16 бит. Размер переменной определяется по директиве, указанной в её объявлении. Если можно определить размер только одного операнда, то размер второго операнда подгоняется под размер первого, если это возможно. Если же можно определить размеры обоих операндов, то они должны совпадать.

</p><p class="code">
<code>x db ?

mov   x, 0		; 0 может иметь любой размер, в данном случае берётся 1 байт
mov   eax, 0		; 0 может иметь любой размер, в данном случае берётся 4 байта
mov   al, 1000h		; Ошибка – попытка записать 2-байтное число в 1-байтный регистр
mov   eax, cx		; Ошибка – размеры операндов не совпадают
</code>

</p><p>
Однако не всегда бывает возможно определить размер пересылаемой величины по операндам команды <span class="mnemo">MOV</span>. Например, если один из операндов является ячейкой памяти, адрес которой записан в регистре, то по этому адресу можно записать и 1 байт, и 2 байта, и 4 байта. Если второй операнд является регистром, то размер пересылаемых данных определяется по размеру регистра. Если же второй операнд является константой, то размер пересылаемых данных определить нельзя, и компилятор фиксирует ошибку. Для того чтобы избежать этой ошибки, надо явно указать размер пересылаемых данных. Для этого используется оператор <span class="mnemo">PTR</span>:

</p><p class="code">
<code>&lt;тип&gt; <span class="mnemo">PTR</span> &lt;выражение&gt;
</code>

</p><p>
В качестве типа используется <span class="mnemo">BYTE</span>, <span class="mnemo">WORD</span> или <span class="mnemo">DWORD</span>.

</p><p class="code">
<code>mov   [ebx], 0			; Ошибка, т.к. 0 может иметь любой размер
mov   byte ptr [ebx], 0 	; Пересылаем 1 байт
mov   dword ptr [ebx], 0 	; Пересылаем 4 байта
</code>


</p><h2 id="a3_3">3.3. Команды сложения и вычитания</h2>

<p>
Команды <i>сложения</i> и <i>вычитания</i> реализуют хорошо всем известные арифметические операции. Единственное, что нужно учитывать при использовании этих команд – особенности сложения и вычитания, связанные с представлением чисел в памяти компьютера.

</p><p class="code">
<code><span class="mnemo">ADD</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;
<span class="mnemo">SUB</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;
</code>

</p><p>
Команда <span class="mnemo">ADD</span> складывает операнды и записывает их сумму на место первого операнда. Команда <span class="mnemo">SUB</span> вычитает из первого операнда второй и записывает полученную разность на место первого операнда. Операнды должны иметь одинаковый размер. Если первый операнд – регистр, то второй может быть также регистром, ячейкой памяти и непосредственным операндом. Если первый операнд – ячейка памяти, то второй операнд может быть регистром или непосредственным операндом. Возможно сложение и вычитание как знаковых, так и беззнаковых чисел любого размера. Команды меняют флаги AF, CF, OF, PF, SF и ZF.

</p><p class="code">
<code>a dd 45d
b dd -32d
c dd ?

mov   eax, a
add   eax, b
mov   c, eax		; c = a + b
</code>

</p><p>
Команды <i>инкремента</i> и <i>декремента</i> увеличивают и уменьшают на 1 свой операнд.

</p><p class="code">
<code><span class="mnemo">INC</span> &lt;операнд&gt;
<span class="mnemo">DEC</span> &lt;операнд&gt;
</code>

</p><p>
Операндом может быть регистр или ячейка памяти любого размера. Команды меняют флаги AF, OF, PF, SF и ZF. Команды инкремента и декремента выгодны тем, что они занимают меньше места, чем соответствующие команды сложения и вычитания.

</p><p class="code">
<code>inc   eax</code>

</p><p>
К арифметическим операциям можно также отнести команду <i>изменения знака</i>:

</p><p class="code">
<code><span class="mnemo">NEG</span> &lt;операнд&gt;
</code>

</p><p>
Операндом может быть регистр или ячейка памяти любого размера. Команда <span class="mnemo">NEG</span> рассматривает свой операнд как число со знаком и меняет знак операнда на противоположный. Команда меняет флаги AF, CF, OF, PF, SF и ZF.

</p><p class="code">
<code>mov   ax, 1
neg   ax		; AX = -1 = ffffh
mov   bl, -128
neg   bl		; BL = -128, OF = 1
</code>


</p><h2 id="a3_4">3.4. Команды умножения и деления</h2>

<h3 id="a3_4_1">3.4.1. Команды умножения</h3>

<p>
Сложение и вычитание знаковых и беззнаковых чисел производятся по одним и тем же алгоритмам. Поэтому нет отдельных команд сложения и вычитания для знаковых и беззнаковых чисел. А вот умножение и деление знаковых и беззнаковых чисел производятся по разным алгоритмам, поэтому существуют по две команды умножения и деления.

</p><p>
Для <i>беззнакового умножения</i> используется команда <span class="mnemo">MUL</span>:

</p><p class="code">
<code><span class="mnemo">MUL</span> &lt;операнд&gt;
</code>

</p><p>
Операнд, указываемый в команде, – это один из сомножителей. Он может быть регистром или ячейкой памяти, но не может быть непосредственным операндом.

</p><p>
Местонахождение второго сомножителя и результата фиксировано, и в команде явно не указывается. Если операнд команды <span class="mnemo">MUL</span> имеет размер 1 байт, то второй сомножитель берётся из регистра AL, а результат помещается в регистр AX. Если операнд команды <span class="mnemo">MUL</span> имеет размер 2 байта, то второй сомножитель берётся из регистра AX, а результат помещается в регистровую пару DX:AX. Если операнд команды <span class="mnemo">MUL</span> имеет размер 4 байта, то второй сомножитель берётся из регистра EAX, а результат помещается в регистровую пару EDX:EAX.

</p><p>
Команда меняет флаги CF и OF. Если произведение имеет такой же размер, что и сомножители, то оба флага сбрасываются в 0. Если же размер произведения удваивается относительно размера сомножителей, то оба флага устанавливаются в 1.

</p><p class="code">
<code>x dw 256

mov   ax, 105
mul   x			; AX = AX * x, AX = 26880, CF = OF = 0
mov   eax, 500000
mov   ebx, 100000
mul   ebx		; EDX:EAX = EAX * EBX, EDX:EAX = 50000000000, CF = OF = 1
</code>

</p><p>
Для <i>знакового умножения</i> используется команда <span class="mnemo">IMUL</span>:

</p><p class="code">
<code><span class="mnemo">IMUL</span> &lt;операнд&gt;
<span class="mnemo">IMUL</span> &lt;операнд&gt;, &lt;непосредственный операнд&gt;
<span class="mnemo">IMUL</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;, &lt;непосредственный операнд&gt;
<span class="mnemo">IMUL</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;
</code>

</p><p>
Команда знакового умножения имеет несколько вариантов. Первый соответствует команде <span class="mnemo">MUL</span> – один из сомножителей указывается в команде, второй должен находиться в регистре EAX/AX/AL, а результат помещается в регистры EDX:EAX/DX:AX/AX.

</p><p>
Второй вариант команды <span class="mnemo">IMUL</span> позволяет указать регистр, который будет содержать один из сомножителей. В этот же регистр будет помещён результат. Второй сомножитель указывается непосредственно в команде.

</p><p>
Третий вариант команды <span class="mnemo">IMUL</span> позволяет указать и результат, и оба сомножителя. Однако результат может быть помещён только в регистр, а второй сомножитель может быть только непосредственным операндом. Первый сомножитель может быть регистром или ячейкой памяти.

</p><p>
Четвёртый вариант команды <span class="mnemo">IMUL</span> позволяет указать оба сомножителя. Первый должен быть регистром, а второй – регистром или ячейкой памяти. Результат помещается в регистр, являющийся первым операндом.

</p><p>
Команда <span class="mnemo">IMUL</span> устанавливает флаги так же, как и команда <span class="mnemo">MUL</span>. Однако расширение результата в регистр EDX/DX происходит только при использовании первого варианта команды <span class="mnemo">IMUL</span>. В остальных случаях часть произведения, не помещающаяся в регистр-результат, теряется, даже если в качестве результата указан регистр EAX/AX. При умножении двух 1-байтовых чисел, произведение которых больше байта, но меньше слова, в регистре-результате получается корректное произведение.

</p><p class="code">
<code>mov   eax, 5
mov   ebx, -7
imul  ebx			; EAX = ffffffdd, EDX = ffffffff, CF = 0

mov   ebx, 3
imul  ebx, 6			; EBX = EBX * 6

mov   ebx, 500000
imul  eax, ebx, 100000		; EAX = EBX * 100000, старшая часть результата теряется

x dd 40
mov   eax, 55
imul  eax, x			; EAX = EAX * x
</code>


</p><h3 id="a3_4_2">3.4.2. Команды деления</h3>

<p>
<i>Деление</i>, как и умножение, реализуется двумя командами, предназначенными для знаковых и беззнаковых чисел:

</p><p class="code">
<code><span class="mnemo">DIV</span>  &lt;операнд&gt;			; Беззнаковое деление
<span class="mnemo">IDIV</span> &lt;операнд&gt;			; Знаковое деление
</code>

</p><p>
В командах указывается только один операнд – делитель, который может быть регистром или ячейкой памяти, но не может быть непосредственным операндом. Местоположение делимого и результата для команд деления фиксировано.

</p><p>
Если делитель имеет размер 1 байт, то делимое берётся из регистра AX. Если делитель имеет размер 2 байта, то делимое берётся из регистровой пары DX:AX. Если же делитель имеет размер 4 байта, то делимое берётся из регистровой пары EDX:EAX.

</p><p>
Поскольку процессор работает с целыми числами, то в результате деления получается сразу два числа – частное и остаток. Эти два числа также помещаются в определённые регистры. Если делитель имеет размер 1 байт, то частное помещается в регистр AL, а остаток – в регистр AH. Если делитель имеет размер 2 байта, то частное помещается в регистр AX, а остаток – в регистр DX. Если же делитель имеет размер 4 байта, то частное помещается в регистр EAX, а остаток – в регистр EDX.

</p><p class="code">
<code>mov   ax, 127
mov   bl, 5
div   bl			; AL = 19h = 25,  AH = 02h = 2

mov   ax, 127
mov   bl, -5
idiv  bl			; AL = e7h = -25, AH = 02h = 2

mov   ax, -127
mov   bl, 5
idiv  bl			; AL = e7h = -25, AH = feh = -2

mov   ax, -127
mov   bl, -5
idiv  bl			; AL = 19h = 25,  AH = feh = -2

<b>; x = a * b + c</b>
mov   eax, a
imul  b
add   eax, c			; Операнды команды сложения вычисляются слева направо
mov   x, eax

<b>; x = a + b * c</b>
mov   eax, b
imul  c
add   eax, a			; Операнды команды сложения вычисляются справа налево
mov   x, eax
</code>


</p><h2 id="a3_5">3.5. Изменение размера числа</h2>

<p>
В операциях деления размер делимого в два раза больше, чем размер делителя. Поэтому нельзя просто загрузить данные в регистр EAX и поделить его на какое-либо значение, т.к. в операции деления будет задействован также и регистр EDX. Поэтому прежде чем выполнять деление, надо установить корректное значение в регистр EDX, иначе результат будет неправильным. Значение регистра EDX должно зависеть от значения регистра EAX. Тут возможны два варианта – для знаковых и беззнаковых чисел.

</p><p>
Если мы используем беззнаковые числа, то в любом случае в регистр EDX необходимо записать значение 0: <code>aaaaaaaah → 00000000aaaaaaaah</code>.

</p><p>
Если же мы используем знаковые числа, то значение регистра EDX будет зависеть от знака числа: <code>55555555h → 0000000055555555h</code>, <code>aaaaaaaah → ffffffffaaaaaaaah</code>.

</p><p>
Записать значение 0 не сложно, а вот для знакового расширения необходимо анализировать знак числа. Однако нет необходимости делать это вручную, т.к. язык ассемблера имеет ряд команд, позволяющих расширять байт до слова, слово до двойного слова и двойное слово до учетверённого слова.

</p><p class="code">
<code>cbw			; Знаковое расширение AL до AX
cwd			; Знаковое расширение AX до DX:AX
cwde			; Знаковое расширение AX до EAX
cdq			; Знаковое расширение EAX до EDX:EAX
</code>

</p><p>
Таким образом, если делитель имеет размер 2 или 4 байта, то нужно устанавливать значение не только регистра AX/EAX, но и регистра DX/EDX. Если же делитель имеет размер 1 байт, то можно просто записать делимое в регистр AX.

</p><p class="code">
<code>x dd ?

mov   eax, x		; Заносим в регистр EAX значение переменной <var>x</var>, которое заранее неизвестно
cdq			; Знаковое расширение EAX в EDX:EAX
mov   ebx, 7
idiv  ebx
</code>

</p><p>
В языке ассемблера существуют также команды, позволяющие занести в регистр значение другого регистра или ячейки памяти со знаковым или беззнаковым расширением.

</p><p class="code">
<code><span class="mnemo">MOVSX</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;		; Знаковое расширение – старшие биты заполняются знаковым битом
<span class="mnemo">MOVZX</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;		; Беззнаковое расширение – старшие биты заполняются нулём
</code>

</p><p>
<i>Операнд<sub>1</sub></i> и <i>операнд<sub>2</sub></i> могут иметь любой размер. Понятно, что <i>операнд<sub>1</sub></i> должен быть больше, чем <i>операнд<sub>2</sub></i>. В случае равенства размера операндов следует использовать обычную команду пересылки <span class="mnemo">MOV</span>, которая выполняется быстрее.

</p><p>
Рассмотрим пример: необходимо вычислить <var>x</var> * <var>x</var> * <var>x</var>, где <var>x</var> – 1-байтовая переменная.

</p><p class="code">
<code><b>; Первый вариант</b>
mov   al, x			; Пересылаем x в регистр AL
imul  al			; Умножаем регистр AL на себя, AX = <var>x</var> * <var>x</var>
movsx bx, x			; Пересылаем <var>x</var> в регистр BX со знаковым расширением
imul  bx			; Умножаем AX на BX. Но! – результат размещается в DX:AX

<b>; Второй вариант</b>
mov   al, x			; Пересылаем <var>x</var> в регистр AL
imul  al			; Умножаем регистр AL на себя, AX = <var>x</var> * <var>x</var>
cwde				; Расширяем AX до EAX
movsx ebx, x			; Пересылаем <var>x</var> в регистр EBX со знаковым расширением
imul  ebx			; Умножаем EAX на EBX. Поскольку <var>x</var> – 1-байтовая переменная, результат благополучно помещается в EAX
</code>

</p><p>
Рассмотрим ещё один пример.

</p><p class="code">
<code>mov   eax, x
mov   ebx, 429496730		; 429496730 = 4294967296 / 10
imul  ebx			; EDX = <var>x</var> / 10. Выполняется в ≈5 раз быстрее, чем деление
</code>

</p><p>
Чем обусловлено получение такого результата? Всегда ли будет работать этот механизм?

</p></section>


<section id="a4">
<h1>4. Переходы и циклы</h1>

<p>
Для изменения порядка выполнения команд в языке ассемблера используются команды условного и безусловного перехода, а также команды управления циклом. Все эти команды не меняют флаги.

</p><h2 id="a4_1">4.1. Безусловный переход</h2>

<p>
Команда безусловного перехода имеет следующий синтаксис:

</p><p class="code">
<code><span class="mnemo">JMP</span> &lt;операнд&gt;
</code>

</p><p>
<i>Операнд</i> указывает адрес перехода. Существует два способа указания этого адреса, соответственно различают <i>прямой</i> и <i>косвенный</i> переходы.


</p><h3 id="a4_1_1">4.1.1. Прямой переход</h3>

<p>
Если в команде перехода указывается метка команды, на которую надо перейти, то переход называется <i>прямым</i>.

</p><p class="code">
<code>   jmp   L
   <b>...</b>
L: mov   eax, x
</code>

</p><p>
Вообще, любой переход заключается в изменении адреса следующей исполняемой команды, т.е. в  изменении значения регистра EIP. Казалось бы, в команде перехода должен задаваться именно адрес перехода. Однако в команде прямого перехода задаётся не абсолютный адрес, а разность между адресом перехода и адресом команды перехода. Действие команды перехода заключается в прибавлении этой величины к текущему значению регистра EIP<a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#nota2"><sup>2</sup></a>. Операнд команды перехода рассматривается как поле со знаком, поэтому при сложении его со значением регистра EIP значение в этом регистре может как увеличиться, так и уменьшиться, т.е. возможен переход и вперёд, и назад.

</p><p>
Запись в команде перехода не абсолютного, а относительного адреса перехода позволяет уменьшить размер команды перехода. Абсолютный адрес должен быть 32-битным, а относительный может быть и 8-битным, и 16-битным.


</p><h3 id="a4_1_2">4.1.2. Косвенный переход</h3>

<p>
При <i>косвенном</i> переходе в команде перехода указывается не адрес перехода, а регистр или ячейка памяти, где этот адрес находится. Содержимое указанного регистра или ячейки памяти рассматривается как абсолютный адрес перехода. Косвенные переходы используются в тех случаях, когда адрес перехода становится известен только во время работы программы.

</p><p class="code">
<code>jmp   ebx
</code>


</p><h2 id="a4_2">4.2. Команды сравнения и условного перехода</h2>

<p>
Команды условного перехода осуществляют переход, который выполняется только в случае истинности некоторого условия. Истинность условия проверяется по значениям флагов. Поэтому обычно непосредственно перед командой условного перехода ставится команда <i>сравнения</i>, которая формирует значения флагов:

</p><p class="code">
<code><span class="mnemo">CMP</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;
</code>

</p><p>
Команда сравнения эквивалентна команде <span class="mnemo">SUB</span> за исключением того, что вычисленная разность никуда не заносится. Назначение команды <span class="mnemo">CMP</span> – установка и сброс флагов.

</p><p>
Что касается команд условного перехода, то их достаточно много, но все они записываются единообразно:

</p><p class="code">
<code><span class="mnemo">Jxx</span> &lt;метка&gt;
</code>

</p><p>
Все команды условного перехода можно разделить на три группы.

</p><p>
В первую группу входят команды, которые обычно ставятся после команды сравнения. В их мнемокодах указывается тот результат сравнения, при котором надо делать переход.

</p><table>
<tbody><tr>
  <th> Мнемокод
  </th><th> Название
  </th><th> Условие перехода после команды <span class="mnemo">CMP op<sub>1</sub>, op<sub>2</sub></span>
  </th><th> Значения флагов
  </th><th> Примечание

</th></tr><tr>
  <td> JE
  </td><td> Переход если равно
  </td><td> op1 = op2
  </td><td> ZF = 1
  </td><td rowspan="2" style="text-align: center"> Для всех чисел

</td></tr><tr>
  <td> JNE
  </td><td> Переход если не равно
  </td><td> op1 ≠ op2
  </td><td> ZF = 0

</td></tr><tr style="background-color: #cccccc">
  <td> JL/JNGE
  </td><td> Переход если меньше
  </td><td> op1 &lt; op2
  </td><td> SF ≠ OF
  </td><td rowspan="4" style="text-align: center"> Для чисел  со знаком

</td></tr><tr style="background-color: #cccccc">
  <td> JLE/JNG
  </td><td> Переход если меньше или равно
  </td><td> op1 ≤ op2
  </td><td> SF ≠ OF или ZF = 1

</td></tr><tr style="background-color: #cccccc">
  <td> JG/JNLE
  </td><td> Переход если больше
  </td><td> op1 &gt; op2
  </td><td> SF = OF и ZF = 0

</td></tr><tr style="background-color: #cccccc">
  <td> JGE/JNL
  </td><td> Переход если больше или равно
  </td><td> op1 ≥ op2
  </td><td> SF = OF

</td></tr><tr>
  <td> JB/JNAE
  </td><td> Переход если ниже
  </td><td> op1 &lt; op2
  </td><td> CF = 1
  </td><td rowspan="4" style="text-align: center"> Для чисел  без знака

</td></tr><tr>
  <td> JBE/JNA
  </td><td> Переход если ниже или равно
  </td><td> op1 ≤ op2
  </td><td> CF = 1 или ZF = 1

</td></tr><tr>
  <td> JA/JNBE
  </td><td> Переход если выше
  </td><td> op1 &gt; op2
  </td><td> CF = 0 и ZF = 0

</td></tr><tr>
  <td> JAE/JNB
  </td><td> Переход если выше или равно
  </td><td> op1 ≥ op2
  </td><td> CF = 0
</td></tr></tbody></table>

<p>
Рассмотрим пример: даны две переменные <var>x</var> и <var>y</var>, в переменную <var>z</var> нужно записать максимальное из чисел <var>x</var> и <var>y</var>.

</p><p class="code">
<code>   mov   eax, x
   cmp   eax, y
   jge/jae L				; Используем <span class="mnemo">JGE</span> для знаковых чисел и <span class="mnemo">JAE</span> – для беззнаковых
   mov   eax, y
L: mov   z, eax
</code>

</p><p>
Во вторую группу команд условного перехода входят те, которые обычно ставятся после команд, отличных от команды сравнения, и которые реагируют на то или иное значение какого-либо флага.

</p><table>
<tbody><tr>
  <th> Мнемокод
  </th><th> Условие перехода
  </th><th> Мнемокод
  </th><th> Условие перехода

</th></tr><tr>
  <td> JZ
  </td><td> ZF = 1
  </td><td> JNZ
  </td><td> ZF = 0

</td></tr><tr>
  <td> JS
  </td><td> SF = 1
  </td><td> JNS
  </td><td> SF = 0

</td></tr><tr>
  <td> JC
  </td><td> CF = 1
  </td><td> JNC
  </td><td> CF = 0

</td></tr><tr>
  <td> JO
  </td><td> OF = 1
  </td><td> JNO
  </td><td> OF = 0

</td></tr><tr>
  <td> JP
  </td><td> PF = 1
  </td><td> JNP
  </td><td> PF = 0
</td></tr></tbody></table>


<p>
Рассмотрим пример: пусть <var>a</var>, <var>b</var> и <var>c</var> – беззнаковые переменные размером 1 байт, требуется вычислить <var>c</var> = <var>a</var> * <var>a</var> + <var>b</var>, но если результат превосходит размер байта, передать управление на метку <i>ERROR</i>.

</p><p class="code">
<code>mov   al, a
mul   al
jc    ERROR
add   al, b
jc    ERROR
mov   c, al
</code>

</p><p>
И, наконец, в третью группу входят две команды условного перехода, проверяющие не флаги, а значение регистра ECX или CX:

</p><p class="code">
<code><span class="mnemo">JCXZ</span> &lt;метка&gt;			; Переход, если значение регистра CX равно 0
<span class="mnemo">JECXZ</span> &lt;метка&gt;			; Переход, если значение регистра ECX равно 0
</code>

</p><p>
Однако эта команда выполняется достаточно долго. Выгоднее провести сравнение с нулём и использовать обычную команду условного перехода.

</p><p>
С помощью команд перехода можно реализовать любые разветвления и циклы.

</p><p class="code">
<code><b>; if (x &gt; 0) <i>S</i></b>
    cmp   x, 0
    jle   L
    <b>...</b>				; <i>S</i>
L:  

<b>; if (x) <i>S1</i> else <i>S2</i></b>
    cmp   x, 0
    je    L1
    <b>...</b>				; <i>S1</i>
    jmp   L2
L1: <b>...</b>				; <i>S2</i>
L2:

<b>; if (a &gt; 0 &amp;&amp; b &gt; 0) <i>S</i></b>
    cmp   a, 0
    jle   L
    cmp   b, 0
    jle   L
    <b>...</b>				; <i>S</i>
L:  

<b>; if (a &gt; 0 || b &gt; 0) <i>S</i></b>
    cmp   a, 0
    jg    L1
    cmp   b, 0
    jle   L2
L1: <b>...</b>				; <i>S</i>
L2: 

<b>; if (a &gt; 0 || b &gt; 0 &amp;&amp; c &gt; 0) <i>S</i></b>
    cmp   a, 0
    jg    L1
    cmp   b, 0
    jle   L2
    cmp   c, 0
    jle   L2
L1: <b>...</b>				; <i>S</i>
L2: 

<b>; while (x &gt; 0) do <i>S</i></b>
L1: cmp x, 0
    jle L2
    <b>...</b>				; <i>S</i>
    jmp L1
L2:

<b>; do <i>S</i> while (x &gt; 0)</b>
L:  <b>...</b>				; <i>S</i>
    cmp x, 0
    jg L
</code>


</p><h2 id="a4_3">4.3. Команды управления циклом</h2>

<h3 id="a4_3_1">4.3.1. Команда <span class="mnemo">LOOP</span></h3>

<p>
Команда <span class="mnemo">LOOP</span> позволяет организовать цикл с известным числом повторений:

</p><p class="code">
<code>   mov   ecx, n
L: <b>...</b>
   <b>...</b>
   loop  L
</code>

</p><p>
Команда <span class="mnemo">LOOP</span> требует, чтобы в качестве счётчика цикла использовался регистр ECX. Собственно, команда <span class="mnemo">LOOP</span> вычитает единицу именно из этого регистра, сравнивает полученное значение с нулём и осуществляет переход на указанную метку, если значение в регистре ECX больше 0. Метка определяет смещение перехода, которое не может превышать 128 байт.

</p><p>
При использовании команды <span class="mnemo">LOOP</span> следует также учитывать, что с её помощью реализуется цикл с постусловием, следовательно, тело цикла выполняется хотя бы один раз. Хуже того, если до начала цикла записать в регистр ECX значение 0, то при вычитании единицы, которое выполняется до сравнения с нулём, в регистре ECX окажется ненулевое значение, и цикл будет выполняться 2<sup>32</sup> раз.

</p><p>
Команда <span class="mnemo">LOOP</span> не относится к самым быстрым командам. В большинстве случаев её можно заменить последовательностью других команд.


</p><h3 id="a4_3_2">4.3.2. Команды <span class="mnemo">LOOPE</span>/<span class="mnemo">LOOPZ</span> и <span class="mnemo">LOOPNE</span>/<span class="mnemo">LOOPNZ</span></h3>

<p>
Эти команды похожи на команду <span class="mnemo">LOOP</span>, но позволяют также организовать и досрочный выход из цикла.

</p><p class="code">
<code><span class="mnemo">LOOPE</span> &lt;метка&gt;		; Команды являются синонимами
<span class="mnemo">LOOPZ</span> &lt;метка&gt;
</code>

</p><p>
Действие этой команды можно описать следующим образом: <code>ECX = ECX - 1; if (ECX != 0 &amp;&amp; ZF == 1) goto &lt;метка&gt;;</code>

</p><p>
До начала цикла в регистр ECX необходимо записать число повторений цикла. Команда <span class="mnemo">LOOPE</span>/<span class="mnemo">LOOPZ</span>, как и команда <span class="mnemo">LOOP</span> ставится в конце цикла, а перед ней помещается команда, которая меняет флаг ZF (обычно это команда сравнения <span class="mnemo">CMP</span>). Команда <span class="mnemo">LOOPE</span>/<span class="mnemo">LOOPZ</span> заставляет цикл повторяться ECX раз, но только если предыдущая команда фиксирует равенство сравниваемых величин (вырабатывает нулевой результат, т.е. <span style="white-space: nowrap">ZF&nbsp;=&nbsp;1</span>).

</p><p>
По какой именно причине произошёл выход из цикла надо проверять после цикла. Причём надо проверять флаг ZF, а не регистр ECX, т.к. условие <span style="white-space: nowrap">ZF&nbsp;=&nbsp;0</span> может появиться как раз на последнем шаге цикла, когда и регистр ECX стал нулевым.

</p><p>
Команда <span class="mnemo">LOOPNE</span>/<span class="mnemo">LOOPNZ</span> аналогична команде <span class="mnemo">LOOPE</span>/<span class="mnemo">LOOPZ</span>, но досрочный выход из цикла осуществляется, если <span style="white-space: nowrap">ZF&nbsp;=&nbsp;1</span>.

</p><p>
Рассмотрим пример: пусть в регистре ESI находится адрес начала некоторого массива двойных слов, а в переменной <var>n</var> – количество элементов массива, требуется проверить наличие в массиве элементов, кратных заданному числу <var>x</var>, и занести в переменную <var>f</var> значение 1, если такие элементы есть, и 0 в противном случае.

</p><p class="code">
<code>    mov   ebx, x
    mov   ecx, n
    mov   f, 1
L1: mov   eax, [esi]
    add   esi, 4
    cdq
    idiv  ebx
    cmp   edx, 0
    loopne L1
    je    L2
    mov   f, 0
L2: 
</code>

</p></section>


<section id="a5">
<h1>5. Массивы</h1>

<h2 id="a5_1">5.1. Модификация адресов</h2>

<p>
Как уже было сказано, массивы в языке ассемблера описываются по директивам определения данных с использованием конструкции повторения (см. <a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#a2_6">раздел 2.6</a>). Для того чтобы обратиться к элементу массива, необходимо так или иначе указать <i>адрес</i> начала массива и <i>смещение</i> элемента в массиве. Смещение первого элемента массива всегда равно 0. Смещения остальных элементов массива зависят от размера элементов.

</p><p>
Пусть X – некий массив. Тогда адрес элемента массива можно вычислить по следующей формуле:

</p><p class="code">
<code>адрес(X[i]) = X + (type X) * i, где <var>i</var> – номер элемента массива, начинающийся с 0
</code>

</p><p>
Напомним, что имя переменной эквивалентно её адресу (для массива – адресу начала массива), а операция <code>type</code> определяет размер переменной (для массива определяется размер элемента массива в соответствии с использованной директивой).

</p><p>
Для удобства в языке ассемблера введена операция <i>модификации адреса</i>, которая схожа с индексным выражением в языках высокого уровня – к имени массива надо приписать целочисленное выражение или имя регистра в квадратных скобках:

</p><p class="code">
<code>x[4]
x[ebx]
</code>

</p><p>
Однако принципиальное отличие состоит в том, в программе на языке высокого уровня мы указываем <b>индекс</b> элемента массива, а компилятор умножает его на размер элемента массива, получая <b>смещение</b> элемента массива. В программе на языке ассемблера указывается именно <b>смещение</b>, т.е. программист должен сам учитывать размер элемента массива. Компилятор же языка ассемблера просто прибавляет смещение к указанному адресу. Приведённые выше команды можно записать по-другому:

</p><p class="code">
<code>x + 4
[x + 4]
[x] + [4]
[x][4]
[x + ebx]
[x] + [ebx]
[x][ebx]
</code>

</p><p>
Обратите внимание, что при использовании регистра для модификации адреса наличие квадратных скобок обязательно. В противном случае компилятор зафиксирует ошибку.

</p><p>
Адрес может вычисляться и по более сложной схеме:

</p><p class="code">
<code>&lt;база&gt; + &lt;множитель&gt; * &lt;индекс&gt; + &lt;смещение&gt;
</code>

</p><p>
<i>База</i> – это регистр или имя переменной. <i>Индекс</i> должен быть записан в некотором регистре. <i>Множитель</i> – это константа 1 (можно опустить), 2, 4 или 8. <i>Смещение</i> – целое положительное или отрицательное число.

</p><p class="code">
<code>mov   eax, [ebx + 4 * ecx - 32]
mov   eax, [x + 2 * ecx]
</code>


</p><h2 id="a5_2">5.2. Команда <span class="mnemo">LEA</span></h2>

<p>
Команда <span class="mnemo">LEA</span> осуществляет загрузку в регистр так называемого <i>эффективного адреса</i>:

</p><p class="code">
<code><span class="mnemo">LEA</span> &lt;регистр&gt;, &lt;ячейка памяти&gt;
</code>

</p><p>
Команда не меняет флаги. В простейшем случае с помощью команды <span class="mnemo">LEA</span> можно загрузить в регистр адрес переменной или начала массива:

</p><p class="code">
<code>x dd 100 dup (0)
lea   ebx, x
</code>

</p><p>
Однако поскольку адрес может быть вычислен с использованием операций сложения и умножения, команда <span class="mnemo">LEA</span> имеет также ряд других применений (см. <a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#a8_3_2">раздел 8.3.2</a>).


</p><h2 id="a5_3">5.3. Обработка массивов</h2>

<p>
Пусть есть массив <var>x</var> и переменная <var>n</var>, хранящая количество элементов этого массива.

</p><p class="code">
<code>x dd 100 dup(?)
n dd ?
</code>

</p><p>
Для обработки массива можно использовать несколько способов.

</p><ol style="padding-left: 15pt">
  <li> В регистре можно хранить смещение элемента массива.
</li></ol>

<p class="code">
<code>   mov   eax, 0
   mov   ecx, n
   mov   ebx, 0
L: add   eax, x[ebx]
   add   ebx, type x
   dec   ecx
   cmp   ecx, 0
   jne   L
</code>

</p><ol style="padding-left: 15pt" start="2">
  <li> В регистре можно хранить номер элемента массива и умножать его на размер элемента.
</li></ol>

<p class="code">
<code>   mov   eax, 0
   mov   ecx, n
L: dec   ecx
   add   eax, x[ecx * type x]
   cmp   ecx, 0
   jne   L
</code>

</p><ol style="padding-left: 15pt" start="3">
  <li> В регистре можно хранить адрес элемента массива. Адрес начала массива можно записать в регистр с помощью команды <span class="mnemo">LEA</span>.
</li></ol>

<p class="code">
<code>   mov   eax, 0
   mov   ecx, n
   lea   ebx, x
L: add   eax, [ebx]
   add   ebx, type x
   dec   ecx
   cmp   ecx, 0
   jne   L
</code>

</p><ol style="padding-left: 15pt" start="4">
  <li> При необходимости можно в один регистр записать адрес начала массива, а в другой – номер или смещение элемента массива.
</li></ol>

<p class="code">
<code>   mov   eax, 0
   mov   ecx, n
   lea   ebx, x
L: dec   ecx
   add   eax, [ebx + ecx * type x]
   cmp   ecx, 0
   jne   L
</code>

</p><p>
Модификацию адреса можно производить также по двум регистрам: <code>x[ebx][esi]</code>. Это может быть удобно при работе со структурами данных, которые рассматриваются как матрицы. Рассмотрим для примера подсчёт количества строк матриц с положительной суммой элементов.

</p><p class="code">
<code>    mov   esi, 0			; Начальное смещение строки
    mov   ebx, 0			; EBX будет содержать количество строк, удовлетворяющих условию
    mov   ecx, m			; Загружаем в ECX количество строк
L1: mov   edi, 0			; Начальное смещение элемента в строке
    mov   eax, 0			; EAX будет содержать сумму элементов строки
    mov   edx, n			; Загружаем в EDX количество элементов в строке
L2: add   eax, y[esi][edi]		; Прибавляем к EAX элемент массива
    add   edi, type y			; Прибавляем к смещению элемента в строке размер элемента
    dec   edx				; Уменьшаем на 1 счётчик внутреннего цикла
    cmp   edx, 0			; Сравниваем EDX с нулём
    jne   L2				; Если EDX не равно 0, то переходим к началу цикла
    cmp   eax, 0			; После цикла сравниваем сумму элементов строки с нулём
    jle   L3				; Если сумма меньше или равна 0, то обходим увеличение EBX
    inc   ebx				; Если же сумму больше 0, то увеличиваем EBX
L3: mov   eax, n			; Загружаем в EAX количество элементов в строке
    imul  eax, type y			; Умножаем количество элементов в строке на размер элемента
    add   esi, eax			; Прибавляем к смещению полученный размер строки
    dec   ecx				; Уменьшаем на 1 счётчик внешнего цикла
    cmp   ecx, 0			; Сравниваем ECX с нулём
    jne   L1				; Если ECX не равно 0, то переходим к началу цикла
</code>

</p></section>


<section id="a6">
<h1>6. Поразрядные операции</h1>

<p>
Поразрядные операции реализуют одну и ту же логическую операцию над всеми битами переменной. К поразрядным операциям относят также операции сдвига.


</p><h2 id="a6_1">6.1. Логические команды</h2>

<p>
Операция <i>отрицания</i> меняет значение всех битов переменной на противоположное. Операция имеет один операнд, который может быть регистром или ячейкой памяти. Операция не меняет флаги.

</p><p class="code">
<code><span class="mnemo">NOT</span> &lt;операнд&gt;
</code>

</p><p>
Операция <i>поразрядное «и»</i> выполняет логическое умножение всех пар бит операндов.

</p><p class="code">
<code><span class="mnemo">AND</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;
</code>

</p><p>
Операция <i>поразрядное «или»</i> выполняет логическое сложение всех пар бит операндов.

</p><p class="code">
<code><span class="mnemo">OR</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;
</code>

</p><p>
Операция <i>поразрядное исключающее «или»</i> выполняет сложение по модулю 2 всех пар бит операндов. 

</p><p class="code">
<code><span class="mnemo">XOR</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;
</code>

</p><p>
Операции <span class="mnemo">AND</span>, <span class="mnemo">OR</span> и <span class="mnemo">XOR</span> имеют по два операнда. Первый может быть регистром или ячейкой памяти, а второй – регистром, ячейкой памяти или непосредственным операндом. Операнды должны иметь одинаковый размер. Результат помещается на место первого операнда. Операции меняют флаги CF, OF, PF, SF и ZF.

</p><p>
Операция <span class="mnemo">XOR</span> имеет интересную особенность – если значения операндов совпадают, то результатом будет значение 0. Поэтому операцию <span class="mnemo">XOR</span> используют для обнуления регистров – она выполняется быстрее, чем запись нуля с помощью команды <span class="mnemo">MOV</span>.

</p><p class="code">
<code>xor   eax, eax				; При любом значении EAX результат будет равен 0
</code>

</p><p>
Операцию <span class="mnemo">XOR</span> можно также использовать для обмена значений двух переменных.

</p><p class="code">
<code>xor   eax, ebx				; EAX = EAX xor EBX
xor   ebx, eax				; Теперь EBX содержит исходное значение EAX
xor   eax, ebx				; А теперь EAX содержит исходное значение EBX
</code>


</p><h2 id="a6_2">6.2. Команды сдвига</h2>

<p>
Операции <i>сдвига вправо</i> и <i>сдвига влево</i> сдвигают биты в переменной на заданное количество позиций. Каждая команда сдвига имеет две разновидности:

</p><p class="code">
<code>&lt;мнемокод&gt; &lt;операнд&gt;, &lt;непосредственный операнд&gt;
&lt;мнемокод&gt; &lt;операнд&gt;, CL
</code>

</p><p>
Первый операнд должен быть регистром или ячейкой памяти. Именно в нём осуществляется сдвиг. Второй операнд определяет количество позиций для сдвига, которое задаётся непосредственным операндом или хранится в регистре CL (и только CL).

</p><p>
Команды сдвига меняют флаги CF, OF, PF, SF и ZF.

</p><p>
Существует несколько разновидностей сдвигов, которые отличаются тем, как заполняются «освобождающиеся» биты.


</p><h3 id="a6_2_1">6.2.1. Логические сдвиги</h3>

<p>
При <i>логическом сдвиге</i> «освобождающиеся» биты заполняются нулями. Последний ушедший бит сохраняется во флаге CF.

</p><p class="code">
<code><span class="mnemo">SHL</span> &lt;операнд&gt;, &lt;количество&gt;				; Логический сдвиг влево
<span class="mnemo">SHR</span> &lt;операнд&gt;, &lt;количество&gt;				; Логический сдвиг вправо
</code>


</p><h3 id="a6_2_2">6.2.2. Арифметические сдвиги</h3>

<p>
<i>Арифметический сдвиг влево</i> эквивалентен логическому сдвигу влево (это одна и та же команда) – «освобождающие» биты заполняются нулями. При <i>арифметическом сдвиге вправо</i> «освобождающиеся» биты заполняются знаковым битом. Последний ушедший бит сохраняется во флаге CF.

</p><p class="code">
<code><span class="mnemo">SAL</span> &lt;операнд&gt;, &lt;количество&gt;				; Арифметический сдвиг влево
<span class="mnemo">SAR</span> &lt;операнд&gt;, &lt;количество&gt;				; Арифметический сдвиг вправо
</code>


</p><h3 id="a6_2_3">6.2.3. Циклические сдвиги</h3>

<p>
При <i>циклическом сдвиге</i> «освобождающиеся» биты заполняются ушедшими битами. Последний ушедший бит сохраняется во флаге CF.

</p><p class="code">
<code><span class="mnemo">ROL</span> &lt;операнд&gt;, &lt;количество&gt;				; Циклический сдвиг влево
<span class="mnemo">ROR</span> &lt;операнд&gt;, &lt;количество&gt;				; Циклический сдвиг вправо
</code>


</p><h3 id="a6_2_4">6.2.4. Расширенные сдвиги</h3>

<p>
<i>Расширенные сдвиги</i> немного отличаются от остальных сдвигов. В расширенных сдвигах участвуют два регистра или ячейка памяти и регистр, которые как бы объединяются в единое целое и «освобождающиеся» биты одного операнда заполняются битами из другого операнда.

</p><p class="code">
<code><span class="mnemo">SHLD</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;, &lt;количество&gt;		; Расширенный сдвиг влево
<span class="mnemo">SHRD</span> &lt;операнд<sub>1</sub>&gt;, &lt;операнд<sub>2</sub>&gt;, &lt;количество&gt;		; Расширенный сдвиг вправо
</code>

</p><p>
Команда <span class="mnemo">SHLD</span> сдвигает влево биты <i>операнда<sub>1</sub></i> на указанное количество позиций. Младшие («освободившиеся») биты <i>операнда<sub>1</sub></i> заполняются старшими битами <i>операнда<sub>2</sub></i>. Сам <i>операнд<sub>2</sub></i> не меняется.

</p><p>
Команда <span class="mnemo">SHRD</span> сдвигает вправо биты <i>операнда<sub>1</sub></i> на указанное количество позиций. Старшие («освободившиеся») биты <i>операнда<sub>1</sub></i> заполняются младшими битами <i>операнда<sub>2</sub></i>. Сам <i>операнд<sub>2</sub></i> не меняется.

</p><p>
<i>Количество</i>, как и в других операциях сдвига, задаётся непосредственным операндом или хранится в регистре CL. Но используются только последние 5 бит операнда, определяющего <i>количество</i>, т.е. максимальное количество позиций сдвига равно 32.

</p><p>
Команды расширенного сдвига обычно используют для создания упакованных данных.


</p><h2 id="a6_3">6.3. Умножение и деление с помощью поразрядных операций</h2>

<p>
Для любой системы счисления сдвиг числа влево или вправо соответствует умножению или делению на основание системы счисления в некоторой степени. Двоичная система счисления, используемая в компьютере, не является исключением. Причём команды сдвига работают на порядок быстрее обычных операций умножения и деления.


</p><h3 id="a6_3_1">6.3.1. Умножение</h3>

<p>
Для умножения используется сдвиг влево. Несмотря на наличие двух команда, по сути, сдвиг влево один. Он используется для умножения как знаковых, так и беззнаковых чисел. Однако результат будет правильным, только в том случае, если он умещается в регистр или ячейку памяти.

</p><p class="code">
<code>mov   ax, 250			; AX = 00fah = 250
sal   ax, 4			; Умножение на 24 = 16, AX = 0fa0h = 4000

mov   ax, 1			; AX = 1
sal   ax, 10			; Умножение на 210, AX = 0400h = 1024

mov   ax, -48			; AX = ffd0h = -48 (в дополнительном коде)
sal   ax, 2			; AX = ff40h = -192 (в дополнительном коде)

mov   ax, 26812			; AX = 68bch = 26812
sal   ax, 1			; AX = d178h = -11912
				; Знаковое положительное число перешло в отрицательное

mov   ax, 32943			; AX = 80afh = 32943
sal   ax, 2			; AX = 02bch = 700
				; Большое беззнаковое число стало гораздо меньше
</code>

</p><p>
Сочетая сдвиги со сложением и вычитанием можно выполнить умножение на любое положительное число. Для умножения на отрицательное число следует добавить команду <span class="mnemo">NEG</span>.

</p><p class="code">
<code>mov   ebx, x
mov   eax, ebx
sal   eax, 2
add   eax, ebx			; EAX = <var>x</var> * 5

mov   ebx, x
mov   eax, ebx
sal   eax, 3
sub   eax, ebx			; EAX = <var>x</var> * 7

mov   ebx, x
mov   eax, ebx
sal   eax, 2
add   eax, ebx
sal   eax, 1			; EAX = <var>x</var> * 10
</code>

</p><p>
Такой набор операций выполняется в 1.5-2 раза быстрее, чем обычное умножение. Но если оба сомножителя заранее неизвестны, то лучше использовать умножение.


</p><h3 id="a6_3_2">6.3.2. Деление</h3>

<p>
Для деления используется сдвиг вправо. При делении нет проблем с переполнением, но для знаковых и беззнаковых чисел надо использовать разные механизмы.

</p><p>
Для деления беззнаковых чисел следует использовать логический сдвиг вправо.

</p><p class="code">
<code>mov   ax, 43013			; AX = a805h = 43013
shr   ax, 1			; AX = 5402h = 21506
</code>

</p><p>
Со знаковыми числами дело обстоит несколько сложнее. В принципе, для деления знаковых чисел следует использовать арифметический сдвиг вправо. Однако для отрицательных чисел получается не совсем корректный результат: 1 / 2 = 0, 3 / 2 = 1, но  -1 / 2 =  -1,  -3 / 2 =  -2,, т.е. результат  отличается от правильного на единицу. Для того чтобы получить правильный результат, необходимо прибавить к делимому делитель, уменьшенный на 1. Однако это необходимо только для отрицательных чисел, поэтому для того, чтобы не делать проверок, используют следующий алгоритм.

</p><p class="code">
<code><b>; Деление на 2</b>
mov   eax, x
cdq				; Расширяем двойное слово до учетверённого. Если в регистре EAX находится положительное число,
				; то регистр EDX будет содержать 0, а если в регистре EAX находится отрицательное число,
				; то регистр EDX будет содержать -1 (ffffffffh)
sub   eax, edx			; Если регистр EDX содержит 0, то регистр EAX не меняется. Если же регистр EDX содержит -1
				; (при отрицательном EAX), то к EAX будет прибавлена требуемая единица
sar   eax, 1

<b>; Деление на 2<sup><i>n</i></sup> (в данном примере <i>n</i> = 3)</b>
mov   eax, x
cdq				; Расширяем двойное слово до учетверённого
and   edx, 111b			; Если EAX отрицателен, то EDX содержит делитель, уменьшенный на 1
add   eax, edx			; Если EAX отрицателен, прибавляем полученное значение
sar   eax, 3			; Если EAX был положителен, то EDX = 0, и предыдущие две операции ничего не меняют
</code>

</p><p>
Если число беззнаковое или если мы знаем, что число положительное, можно просто использовать сдвиг вправо, который выполняется примерно в 10 раз быстрее, чем деление. Если же для знакового числа не известно, положительное оно или отрицательное, то придётся использовать вышеприведённую последовательность команд, которая, однако, также выполняется примерно в 5-7 раз быстрее, чем деление.


</p><h3 id="a6_3_3">6.3.3. Получение остатка от деления</h3>

<p>
Для беззнаковых и положительных чисел остаток от деления на 2<sup><i>n</i></sup> – это последние <i>n</i> бит числа. Поэтому для получения остатка от деления на 2<sup><i>n</i></sup> нужно выделить эти последние <i>n</i> бит с помощью операции <span class="mnemo">AND</span>.

</p><p class="code">
<code>mov   eax, x
and   eax, 111b			; EAX = EAX % 2<sup>3</sup>
</code>

</p><p>
Для отрицательного делимого <var>x</var> и положительного делителя <var>n</var> <code>(x % n) = -(-x % n)</code>.

</p><p class="code">
<code>mov   eax, x
neg   eax
and   eax, 1111b		; EAX = EAX % 2<sup>4</sup>
neg   eax
</code>

</p></section>


<section id="a7">
<h1>7. Программа. Процедуры</h1>

<h2 id="a7_1">7.1. Структура программы на языке ассемблера</h2>

<p>
Программа на языке ассемблера имеет следующую структуру:

</p><p class="code">
<code>.686
.model flat, stdcall
option casemap: none

.data
   &lt;инициализированные данные&gt;
   
.data?
   &lt;неинициализированные данные&gt;
   
.const
   &lt;константы&gt;
   
.code
&lt;метка&gt;
   &lt;код&gt;
end &lt;метка&gt;
</code>

</p><p>
Директива <code>.686</code> указывает компилятору ассемблера, что необходимо использовать набор операций процессора определённого поколения.

</p><p>
Директива <code>.model</code> позволяет указывать используемую модель памяти и соглашение о вызовах. Как уже было сказано, на архитектуре Win32 используется только одна модель памяти – <i>flat</i>, что и указано в приведённом примере. Соглашения о вызовах определяют порядок передачи параметров и порядок очистки стека.

</p><p>
Директива <code>option&nbsp;casemap:&nbsp;none</code> заставляет компилятор языка ассемблера различать большие и маленькие буквы в метках и именах процедур.

</p><p>
Директивы <code>.data</code>, <code>.data?</code>, <code>.const</code> и <code>.code</code> определяют то, что называется секциями. В Win32 нет сегментов, но адресное пространство можно поделить на логические секции. Начало одной секции отмечает конец предыдущей. Есть две группы секций: данных и кода.

</p><p>
Секция <code>.data</code> содержит инициализированные данные программы.

</p><p>
Секция <code>.data?</code> содержит неинициализированные данные программы. Иногда нужно только предварительно выделить некоторое количество памяти, не инициализируя её. Эта секция для этого и предназначается. Преимущество неинициализированных данных в том, что они не занимают места в исполняемом файле. Вы всего лишь сообщаете компилятору, сколько места вам понадобится, когда программа загрузится в память.

</p><p>
Секция <code>.const</code> содержит объявления констант, используемых программой. Константы не могут быть изменены. Попытка изменить константу вызывает аварийное завершение программы. 

</p><p>
Задействовать все три секции не обязательно.

</p><p>
Есть только одна секция для кода: <code>.code</code>. В ней содержится весь код. 

</p><p>
Предложения <code>&lt;метка&gt;</code> и <code>end &lt;метка&gt;</code> устанавливают границы кода. Обе метки должны быть идентичны. Весь код должен располагаться между этими предложениями.

</p><p>
Любая программа под Windows должна, как минимум, корректно завершится. Для этого необходимо вызвать функцию Win32 API <i>ExitProcess</i>.

</p><p class="code">
<code>.686
.model flat, stdcall
option casemap: none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib

.code
program:
    push  0
    call  ExitProcess
end program
</code>

</p><p>
Выше приведён пример минимальной программы на языке ассемблера, которая делает только одно – корректно завершается. В ней появились две новые директивы: <code>include</code> и <code>includelib</code>. Первая позволяет включать в программу файлы, содержащие прототипы процедур, а также определения констант и структур, которые могут понадобиться для программирования под Win32. Вторая директива указывает, какие библиотеки использует программа. Компоновщик должен будет прилинковать их. Без указания включаемого файла <i>kernel2.inc</i> и библиотеки импорта <i>kernel32.lib</i> невозможно будет вызвать процедуру <i>ExitProcess</i>. Файл <i>windows.inc</i> в данном случае включать не обязательно, но он требуется достаточно часто, а включаемые файлы не увеличивают размер получаемой программы.

</p><p>
Команда <span class="mnemo">PUSH</span> кладёт в стек параметр для процедуры <i>ExitProcess</i>. Этот параметр определяет код завершения. Значение 0 – это код нормального завершения программы.

</p><p>
Команда <span class="mnemo">CALL</span> вызывает процедуру <i>ExitProcess</i>.

</p><p>
Если вы используете компилятор MASM32, то пункт меню <i>Project</i> содержит команды <i>Assemble&nbsp;&amp;&nbsp;Link</i> и <i>Console&nbsp;Assemble&nbsp;&amp;&nbsp;Link</i>, которые позволяют скомпилировать обычное и консольное приложение под Windows. Приведённую программу можно откомпилировать обоими способами.


</p><h2 id="a7_2">7.2. Команды работы со стеком</h2>

<p>
Работа со стеком имеет непосредственное отношение к процедурам, т.к. стек используется для передачи параметров и для хранения локальных данных процедур. В принципе, для работы со стеком существуют всего две операции: положить данные и взять данные. Для каждой операции существует несколько команд, которые отличаются тем, с какими данными они работают.

</p><p>
Для того чтобы положить данные в стек используется команда <span class="mnemo">PUSH</span>:

</p><p class="code">
<code><span class="mnemo">PUSH</span> &lt;операнд&gt;
</code>

</p><p>
<i>Операнд</i> может быть регистром, ячейкой памяти или непосредственным операндом. Размер операнда должен быть 2 или 4 байта. Операнд кладётся на вершину стека, а значение регистра ESP уменьшается на размер операнда.

 </p><p class="img"><img class="asm" src="./Программирование на языке ассемблера_files/Push.gif" alt="">

</p><p>
Для того чтобы взять данные из стека используется команда <span class="mnemo">POP</span>:

</p><p class="code">
<code><span class="mnemo">POP</span> &lt;операнд&gt;
</code>

</p><p>
<i>Операнд</i> может быть регистром или ячейкой памяти. Размер операнда должен быть 2 или 4 байта. В соответствии с размером операнда из вершины стека берутся 2 или 4 байта и помещаются в указанный регистр или ячейку памяти. Значение регистра ESP увеличивается на размер операнда.

 </p><p class="img"><img class="asm" src="./Программирование на языке ассемблера_files/Pop.gif" alt="">

</p><p>
Кроме этих основных команд существуют ещё команды, которые позволяют сохранять в стеке и восстанавливать из стека содержимое всех регистров общего назначения, и команды, которые позволяют сохранять в стеке и восстанавливать из стека содержимое регистра флагов.

</p><p class="code">
<code><span class="mnemo">PUSHA</span>
<span class="mnemo">PUSHAD</span>
</code>

</p><p>
Команда <span class="mnemo">PUSHA</span> сохраняет в стеке содержимое регистров AX, CX, DX, BX, SP, BP, SI, DI. Команда <span class="mnemo">PUSHAD</span> сохраняет в стеке содержимое регистров EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI. Для регистра (E)SP сохраняется значение, которое было до того, как мы положили регистры в стек. После этого значение регистра (E)SP изменяется как обычно.

</p><p class="code">
<code><span class="mnemo">POPA</span>
<span class="mnemo">POPAD</span>
</code>

</p><p>
Эти команды противоположны предыдущим – они восстанавливают из стека значения регистров (E)DI, (E)SI, (E)BP, (E)SP, (E)BX, (E)DX, (E)CX, (E)AX. Содержимое регистра (E)SP не восстанавливается из стека, а изменяется как обычно.

</p><p class="code">
<code><span class="mnemo">PUSHF</span>
<span class="mnemo">PUSHFD</span>
</code>

</p><p>
Команда <span class="mnemo">PUSHF</span> сохраняет в стеке младшие 16 бит регистра флагов. Команда <span class="mnemo">PUSHFD</span> сохраняет в стеке все 32 бита регистра флагов.

</p><p class="code">
<code><span class="mnemo">POPF</span>
<span class="mnemo">POPFD</span>
</code>

</p><p>
Команда <span class="mnemo">POPF</span> восстанавливает из стека младшие 16 бит регистра флагов. Команда <span class="mnemo">POPFD</span> восстанавливает из стека все 32 бита регистра флагов.


</p><h2 id="a7_3">7.3. Синтаксис процедуры</h2>

<p>
Описание процедуры на языке ассемблера выглядит следующим образом:

</p><p class="code">
<code>&lt;имя процедуры&gt; <span class="mnemo">PROC</span>
 &lt;тело процедуры&gt;
&lt;имя процедуры&gt; <span class="mnemo">ENDP</span>
</code>

</p><p>
Несмотря на то, что после имени процедуры не ставится двоеточие, это имя является меткой, обозначающей первую команду процедуры.

</p><p>
В языке ассемблера имена и метки, описанные в процедуре, не локализуются внутри неё, поэтому они должны быть уникальны.

</p><p>
Размещать процедуру в программе на языке ассемблера следует таким образом, чтобы команды процедуры выполнялись не сами по себе, а только тогда, когда происходит обращение к процедуре. Обычно процедуры размещают либо в конце секции кода после вызова функции <i>ExitProcess</i>, либо в самом начале секции кода, сразу после директивы <code>.code</code>.


</p><h2 id="a7_4">7.4. Вызов процедуры и возврат из процедуры</h2>

<p>
Вызов процедуры – это, по сути, передача управления на первую команду процедуры. Для передачи управления можно использовать команду безусловного перехода на метку, являющуюся именем процедуры. Можно даже не использовать директивы <code>proc</code> и <code>endp</code>, а написать обычную метку с двоеточием после вызова функции <i>ExitProcess</i>.

</p><p>
С возвратом из процедуры дело обстоит сложнее. Дело в том, что обращаться к процедуре можно из разных мест основной программы, а потому и возврат из процедуры должен осуществляться в разные места. Сама процедура не знает, куда надо вернуть управление, зато это знает основная программа. Поэтому при обращении к процедуре основная программа должна сообщить ей <i>адрес возврата</i>, т.е. адрес той команды, на которую процедура должна сделать переход по окончании своей работы. Поскольку при разных обращениях к процедуре будут указываться разные адреса возврата, то и возврат управления будет осуществляться в разные места программы. Адрес возврата принято передавать через стек.

</p><p class="code">
<code>.686
.model flat, stdcall
option casemap: none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib

.code
program:
   push  L
   jmp   Procedure
L: nop

   push  0
   call  ExitProcess

Procedure:
   pop   eax
   jmp   eax
end program
</code>

</p><p>
Однако так обычно не делают – система команд языка ассемблера включает специальные команды для вызова процедуры и возврата из процедуры.

</p><p class="code">
<code><span class="mnemo">CALL</span> &lt;имя процедуры&gt;			; Вызов процедуры
<span class="mnemo">RET</span>					; Возврат из процедуры
</code>

</p><p>
Команда <span class="mnemo">CALL</span> записывает адрес следующей за ней команды в стек и осуществляет переход на первую команду указанной процедуры. Команда <span class="mnemo">RET</span> считывает из вершины стека адрес и выполняет переход по нему.

</p><p class="code">
<code>.686
.model flat, stdcall
option casemap: none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib

.code
program:
   call  Procedure

   push  0
   call  ExitProcess

Procedure proc
   ret
Procedure endp

end program
</code>


</p><h2 id="a7_5">7.5. Передача параметров процедуры</h2>

<p>
Существуют несколько способов передачи параметров в процедуру.

</p><ol style="padding-left: 15pt">
  <li style="font-style: italic"> Параметры можно передавать через регистры.
</li></ol>

<p>
Если процедура получает небольшое число параметров, идеальным местом для их передачи оказываются регистры. Существуют соглашения о вызовах, предполагающие передачу параметров через регистры ECX и EDX. Этот метод самый быстрый, но он удобен только для процедур с небольшим количеством параметров.

</p><ol style="padding-left: 15pt" start="2">
  <li style="font-style: italic"> Параметры можно передавать в глобальных переменных.
</li></ol>

<p>
Параметры процедуры можно записать в глобальные переменные, к которым затем будет обращаться процедура. Однако этот метод является неэффективным, и его использование может привести к тому, что рекурсия и повторная входимость<a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#nota3"><sup>3</sup></a> станут невозможными.

</p><ol style="padding-left: 15pt" start="3">
  <li style="font-style: italic"> Параметры можно передавать в блоке параметров.
</li></ol>

<p>
Блок параметров – это участок памяти, содержащий параметры и располагающийся обычно в сегменте данных. Процедура получает адрес начала этого блока при помощи любого метода передачи параметров (в регистре, в переменной, в стеке, в коде или даже в другом блоке параметров).

</p><ol style="padding-left: 15pt" start="4">
  <li style="font-style: italic"> Параметры можно передавать через стек.
</li></ol>

<p>
Передача параметров через стек – наиболее распространённых способ. Именно его используют языки высокого уровня, такие как С++ и Паскаль. Параметры помещаются в стек непосредственно перед вызовом процедуры.

</p><p>
При внимательном анализе этого метода передачи параметров возникает сразу два вопроса: кто должен удалять параметры из стека, процедура или вызывающая её программа, и в каком порядке помещать параметры в стек. В обоих случаях оказывается, что оба варианта имеют свои «за» и «против». Если стек освобождает процедура, то код программы получается меньшим, а если за освобождение стека от параметров отвечает вызывающая программа, то становится возможным вызвать несколько функций с одними и теми же параметрами просто последовательными командами <span class="mnemo">CALL</span>. Первый способ, более строгий, используется при реализации процедур в языке Паскаль, а второй, дающий больше возможностей для оптимизации, – в языке С++.

</p><p>
Основное соглашение о вызовах языка Паскаль предполагает, что параметры кладутся в стек в прямом порядке. Соглашения о вызовах языка С++, в том числе одно из основных соглашений о вызовах ОС&nbsp;Windows <i>stdcall</i>, предполагают, что параметры помещаются в стек в обратном порядке. Это делает возможной реализацию функций с переменным числом параметров (как, например, <i>printf</i>). При этом первый параметр определяет число остальных параметров.

</p><p class="code">
<code>push &lt;параметр<sub><i>n</i></sub>&gt;
<b>...</b>
push &lt;параметр<sub>1</sub>&gt;
call Procedure
</code>

</p><p>
В приведённом выше участке кода в стек кладутся несколько параметров и затем вызывается процедура. Следует помнить, что команда <span class="mnemo">CALL</span> также кладёт в стек адрес возврата. Таким образом, перед выполнением первой команды процедуры стек будет выглядеть следующим образом.

 </p><p class="img"><img class="asm" src="./Программирование на языке ассемблера_files/Parameters.gif" alt="Передача параметров через стек">

</p><p>
Адрес возврата оказывается в стеке поверх параметров. Однако поскольку в рамках своего участка стека процедура может обращаться без ограничений к любой ячейки памяти, нет необходимости перекладывать куда-то адрес возврата, а потом возвращать его обратно в стек. Для обращения к первому параметру используют адрес [ESP&nbsp;+&nbsp;4] (прибавляем 4, т.к. на архитектуре Win32 адрес имеет размер 32 бита), для обращения ко второму параметру – адрес [ESP&nbsp;+&nbsp;8] и т.д.

</p><p>
После завершения работы процедуры необходимо освободить стек. Если используется соглашение о вызовах <i>stdcall</i> (или любое другое, предполагающее, что стек освобождается процедурой), то в команде <span class="mnemo">RET</span> следует указать суммарный размер в байтах всех параметров процедуры. Тогда команда <span class="mnemo">RET</span> после извлечения адреса возврата прибавит к регистру ESP указанное значение, освободив таким образом стек. Если же используется соглашение о вызовах <i>cdecl</i> (или любое другое, предполагающее, что стек освобождается вызывающей программой), то после команды <span class="mnemo">CALL</span> следует поместить команду, которая прибавит к регистру ESP нужное значение.

</p><p class="code">
<code><b>; Передача параметров и возврат из процедуры с использованием соглашения о вызовах <i>stdcall</i></b>
.686
.model flat, <b>stdcall</b>
option casemap: none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib

.data
  x dd 0
  y dd 4

.code
program:
   push  y			; Кладём в стек два параметра размером по 4 байта
   push  x
   call  Procedure

   push  0
   call  ExitProcess

Procedure proc
   ret   8			; В команде возврата указываем, что надо освободить 8 байт стека
Procedure endp

end program

<b>; Передача параметров и возврат из процедуры с использованием соглашения о вызовах <i>cdecl</i></b>
.686
.model flat, <b>c</b>
option casemap: none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib

.data
  x dd 0
  y dd 4

.code
program:
   push  y			; Кладём в стек два параметра размером по 4 байта
   push  x
   call  Procedure
   add   esp, 8			; Освобождаем 8 байт стека

   push  0
   call  ExitProcess

Procedure proc
   ret				; Используем команду возврата без параметров
Procedure endp

end program
</code>

</p><ol style="padding-left: 15pt" start="5">
  <li style="font-style: italic"> Параметры можно передавать в потоке кода.
</li></ol>

<p>
В этом необычном методе передаваемые процедуре данные размещаются прямо в коде программы, сразу после команды <span class="mnemo">CALL</span>. Чтобы прочитать параметр, процедура должна использовать его адрес, который автоматически передаётся в стеке как адрес возврата из процедуры. Разумеется, процедура должна будет изменить адрес возврата на первый байт после конца переданных параметров перед выполнением команды <span class="mnemo">RET</span>.

</p><p class="code">
<code>.686
.model flat, stdcall
option casemap: none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib

.code
program:
    call  Procedure		; Команда <span class="mnemo">CALL</span> кладёт в стек адрес следующей команды
    db    'string',0		; В нашем случае – адрес начала строки

    push  0
    call  ExitProcess

Procedure proc
    pop   esi			; Извлекаем из стека адрес начала строки
    xor   eax, eax		; Обнуляем EAX, в нём будет храниться количество символов
L1: mov   bl, [esi]		; Заносим в регистр BL байт, хранящийся по адресу ESI
    inc   esi			; Увеличиваем значение в регистре ESI на 1
    inc   eax			; Увеличиваем значение в регистре EAX на 1
    cmp   bl, 0			; Сравниваем прочитанный символ с нулём
    jne   L1			; Если не 0, переходим к началу цикла
    push  esi			; Кладём в стек адрес байта, следующего сразу за строкой
    ret				; Возврат из процедуры
Procedure endp

end program
</code>


</p><h2 id="a7_6">7.6. Передача результата процедуры</h2>

<p>
Для передачи результата процедуры обычно используется регистр EAX. Этот способ используется не только в программах на языке ассемблера, но и в программах на языке С++. Объекты, имеющие размер не более 8 байт, могут передаваться через регистровую пару EDX:EAX. Вещественные числа передаются через вершину стека вещественных регистров. Если эти способы не подходят, то следует передать в качестве параметра адрес ячейки памяти, куда будет записан результат.

</p><p class="code">
<code><b>; Передача параметров через стек, возврат результата через регистр EAX</b>
.686
.model flat, c
option casemap: none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib

.data
  a dd 76
  b dd -8
  d dd ?

.code
program:
   push  b			; Кладём параметры в стек
   push  a
   call  Procedure
   add   esp, 8			; Освобождаем 8 байт стека
   mov   d, eax			; d = a – b

   push  0
   call  ExitProcess

Procedure proc
   mov   eax, [esp + 4]		; Заносим в регистр EAX первый параметр
   mov   edx, [esp + 8] 	; Заносим в регистр EDX второй параметр
   sub   eax, edx		; В регистре EAX получилась разность параметров
   ret
Procedure endp

end program


<b>; Передача параметров через стек, возврат результата по адресу</b>
.686
.model flat, c
option casemap: none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib

.data
  a dd 76
  b dd -8
  d dd ?

.code
program:
   push  offset d		; Кладём в стек адрес переменной, куда будет записан результат
   push  b
   push  a
   call  Procedure
   add   esp, 12		; Освобождаем 12 байт стека
   
   push  0
   call  ExitProcess

Procedure proc
   mov   eax, [esp + 4]		; Заносим в регистр EAX первый параметр
   mov   edx, [esp + 8] 	; Заносим в регистр EDX второй параметр
   sub   eax, edx		; В регистре EAX получилась разность параметров
   mov   edx, [esp + 12]	; Заносим в регистр EDX третий параметр – адрес результата
   mov   [edx], eax		; Записываем результат по адресу в регистре EDX
   ret
Procedure endp

end program
</code>


</p><h2 id="a7_7">7.7. Сохранение регистров в процедуре</h2>

<p>
Практически любые действия в языке ассемблера требуют использования регистров. Однако регистров очень мало и даже в небольшой программе невозможно будет разделить регистры между частями программы, т.е. договориться, что основная программа использует, например, регистры EAX, ECX, EBP, ESP, а процедура – регистры EBX, EDX, ESI, EDI.  В принципе, сделать так можно, но смысла в этом нет, т.к. программировать будет крайне неудобно, придётся перемещать данные из регистров в оперативную память и обратно, что замедлит выполнение программы. Кроме того, существуют правила, которые изменить нельзя – в регистре ESP хранится адрес вершины стека, а команды умножения и деления всегда используют регистры EAX и EDX. Поэтому получается, что основная программа и процедура вынуждены использовать одни и те же регистры, причём, вычисления в основной программе прерываются для того, чтобы выполнить вычисления процедуры. Таким образом, чтобы основная программа могла продолжить вычисления, процедура должна при выходе восстановить те значения регистров, которые были до начала выполнения процедуры. Естественно, для этого процедуре придётся предварительно сохранить значения регистров. Всё вышесказанное относится также к случаю, когда одна процедура вызывает другую процедуру.

</p><p>
Особенно внимательно следует относиться к регистрам ESI, EDI, EBP и EBX. ОС Windows использует эти регистры для своих целей и не ожидает, что вы измените их значение.

</p><p>
Если вы пишите всю программу целиком, то, в принципе, можете добиться того, что после вызова процедуры в основной программе нужные регистры будут правильно проинициализированы. Если же вы пишите отдельные процедуры, которые затем будут использоваться в другой программе, то никаких гарантий нет, и сохранение и восстановление регистров становится жизненно необходимой операцией.

</p><p>
Где можно сохранить значения регистров? Конечно же, в стеке. Можно сохранить используемые регистры по одному с помощью команды <span class="mnemo">PUSH</span>, или все сразу с помощью команды <span class="mnemo">PUSHAD</span>. В первом случае в конце процедуры нужно будет восстановить значения сохранённых регистров с помощью команды <span class="mnemo">POP</span> в обратном порядке. Во втором случае для восстановления значений регистров используется команду <span class="mnemo">POPAD</span>.

</p><p>
При сохранении регистров указатель стека изменится на некоторое значение, зависящее от количества сохранённых регистров. Это нужно будет учитывать при вычислении адресов параметров процедуры, передаваемых через стек.

</p><p class="code">
<code><b>; Процедура получает два параметра по 4 байта</b>
Procedure proc
    push  esi				; Сохраняем используемые регистры
    push  edi
    mov   esi, [esp + 12]		; Извлекаем параметры из стека. Адрес вычисляется 
    mov   edi, [esp + 16]		; с учётом 8 байт, использованных при сохранении регистров
    <b>...</b>
    pop   edi				; Извлекаем сохранённые регистры из стека
    pop   esi				; в обратном порядке
    ret
Procedure endp

<b>; Процедура получает два параметра по 4 байта</b>
Procedure proc
    pushad				; Сохраняем все регистры
    mov   eax, [esp + 4 + 32]		; Извлекаем параметры из стека. Адрес вычисляется 
    mov   ebx, [esp + 8 + 32]		; с учётом 32 байт, использованных при сохранении регистров
    <b>...</b>
    popad				; Извлекаем сохранённые регистры из стека
    ret
Procedure endp
</code>


</p><h2 id="a7_8">7.8. Локальные данные процедур</h2>

<p>
Процедуры часто нуждаются в локальных данных. Локальные переменные размещаются в стеке. Для того чтобы отвести место под локальные переменные в процедуре на языке ассемблера, достаточно просто вычесть из регистра ESP размер требуемой памяти. После этого все вызываемые процедуры будут «знать», что место в стеке занято, и размещать свои данные в незанятой части стека.

</p><p>
При вызове других процедур, а также в ходе выполнения текущей процедуры в стек могут быть положены другие данные. При этом значение регистра ESP изменится. Поэтому регистр ESP не является надёжной точкой отсчёта для адресов локальных переменных. Для того чтобы получить такую точку отсчёта, значение регистра ESP переписывают в регистр EBP, предварительно сохранив значение регистра EBP в стеке. В этом случае регистр EBP отмечает часть стека, занятую на момент начала работы процедуры (отсюда происходит название регистра EBP – указатель базы кадра стека). При таком подходе первый параметр процедуры всегда находится по адресу [EBP&nbsp;+&nbsp;8]. Адреса локальных переменных отсчитываются от регистра EBP с отрицательным смещением. По окончании работы процедуры значение регистра ESP восстанавливается по регистру EBP, а значение регистра EBP – из стека. 

</p><p class="code">
<code>Procedure proc
    var_104 = byte ptr -104h
    var_4   = dword ptr  -4
    arg_0   = dword ptr   8
    arg_4   = dword ptr  0ch

    push  ebp
    mov   ebp, esp
    sub   esp, 104h
    mov   edx, [ebp + arg_0]
    mov   eax, [ebp + arg_4]
    push  ebx
    push  esi
    push  edi
    <b>...</b>
    pop   edi
    pop   esi
    pop   ebx
    mov   esp, ebp
    pop   ebp
    ret
Procedure endp
</code>

 </p><p class="img"><img class="asm" src="./Программирование на языке ассемблера_files/Locals.gif" alt="Локальные данные">

</p><p>
Такой способ позволяет также отводить различное количество места под локальные данные, и при необходимости не заботится о парности команд <span class="mnemo">PUSH</span> и <span class="mnemo">POP</span>.


</p><h2 id="a7_9">7.9. Рекурсивные процедуры</h2>

<p>
Рекурсия – ресурсоёмкий способ реализации алгоритмов. Она требует много места для хранения локальных данных на каждом шаге рекурсии, кроме того, рекурсивные процедуры обычно выполняются не очень быстро. Поэтому языку ассемблера, предназначенному для написания быстрых программ, рекурсия, в общем, не свойственна. Но при желании и на ассемблере можно написать рекурсивную процедуру. Принципы реализации рекурсивной процедуры на языке ассемблера такие же, как и на других языках. В процедуре должна быть терминальная ветвь, в которой нет рекурсивного вызова, и рабочая ветвь.

</p><p>
При реализации рекурсивных процедур становится особенно важным использование стека для передачи параметров и адреса возврата, что позволяет хранить данные, относящиеся к разным уровням рекурсивных вызовов, в разных областях памяти.

</p><p>
Для примера рассмотрим рекурсивную процедуру вычисления факториала целого беззнакового числа. Процедура получает параметр через стек и возвращает результат через регистр EAX.

</p><p class="code">
<code>factorial proc
     mov   eax, [esp + 4]		; Заносим в регистр EAX параметр процедуры
     test  eax, eax			; Проверяем значение в регистре EAX
     jz    L1				; Если EAX = 0, то обходим рекурсивную ветвь
     dec   eax				; Уменьшаем значение в регистре EAX на 1
     push  eax				; Кладём в стек параметр для следующего рекурсивного вызова
     call  factorial			; Вызываем процедуру
     add   esp, 4			; Очищаем стек, т.к. процедура использует <span class="mnemo">RET</span> без параметров
     mul   dword ptr [esp + 4]		; Умножаем EAX, хранящий результат предыдущего вызова, на параметр текущего вызова процедуры
     ret				; Возврат из процедуры (без параметров)
 L1: inc   eax				; Если EAX был равен 0, записываем в EAX единицу
 L2: ret				; Возврат из процедуры (без параметров)
factorial endp
</code>

</p></section>


<section id="a8">

<h1>8. Оптимизация программ, написанных на языке ассемблера</h1>

<p>
Наиболее популярным применением ассемблера обычно считается именно оптимизация программ, то есть уменьшение времени выполнения программ по сравнению с языками высокого уровня. Но если просто переписать текст, например с языка С на ассемблер, переводя каждую команду наиболее очевидным способом, часто оказывается, что процедура на языке&nbsp;С выполняется быстрее. Вообще говоря, ассемблер, как и любой другой язык, сам по себе не является панацеей от неэффективного программирования – чтобы действительно оптимизировать программу, требуется не только знание команд процессора, но и знание алгоритмов, навык оптимальных способов их реализации и подробная информация об архитектуре процессора.

</p><p>
Проблему оптимизации принято делить на три основных уровня:

</p><ol>
  <li> выбор наиболее оптимального алгоритма – высокоуровневая оптимизация;
  </li><li> наиболее оптимальная реализация алгоритма – оптимизация среднего уровня;
  </li><li> подсчёт тактов, тратящихся на выполнение каждой команды, и оптимизация их порядка для конкретного процессора – низкоуровневая оптимизация.
</li></ol>

<h2 id="a8_1">8.1. Высокоуровневая оптимизация</h2>

<p>
Выбор оптимального алгоритма для решения задачи всегда приводит к лучшим результатам, чем любой другой вид оптимизации. Действительно, при замене пузырьковой сортировки, время выполнения которой пропорционально <span style="white-space: nowrap"><i>n</i><sup>2</sup></span>, на быструю сортировку, время выполнения которой пропорционально <span style="white-space: nowrap"><i>n</i>&nbsp;*&nbsp;log(<i>n</i>)</span>, вторая программа будет выполняться быстрее в подавляющем большинстве случаев, как бы она ни была реализована. Поиск лучшего алгоритма – универсальная стадия, и она относится не только к ассемблеру, но и к любому языку программирования, поэтому будем считать, что оптимальный алгоритм уже выбран.


</p><h2 id="a8_2">8.2. Оптимизация среднего уровня</h2>

<p>
Реализация алгоритма на данном конкретном языке программирования – самая ответственная стадия оптимизации. Именно здесь можно получить выигрыш в скорости в десятки раз или сделать программу в десятки раз медленнее, при серьёзных ошибках в реализации. Методы оптимизации сильно зависят от конкретного реализуемого алгоритма, поэтому невозможно описать правила на все случаи жизни, хотя, конечно, есть ряд общих приёмов, например, хранение переменных, с которыми выполняется активная работа, в регистрах, использование таблиц переходов вместо длинных последовательностей проверок и условных переходов и т.п. Тем не менее, даже плохо реализованные операции не вносят заметных замедлений в программу, если они не повторяются в цикле. Практически можно говорить, что все проблемы оптимизации на среднем уровне так или иначе связаны с циклами, и именно поэтому мы рассмотрим основные правила, которые стоит иметь в виду при реализации любого алгоритма, содержащего циклы.


</p><h3 id="a8_2_1">8.2.1. Вычисление констант вне цикла</h3>

<p>
Самым очевидным и самым важным правилом при создании цикла на любом языке программирования является вынос всех переменных, которые не изменяются на протяжении цикла, за его пределы. В случае ассемблера имеет смысл также по возможности разместить все переменные, которые будут использоваться внутри цикла, в регистры, а старые значения нужных после цикла регистров сохранить в стеке.


</p><h3 id="a8_2_2">8.2.2. Перенос проверки условия в конец цикла</h3>

<p>
Циклы типа <i>while</i> или <i>for</i>, которые так часто применяются в языках высокого уровня, оказываются менее эффективными по сравнению с циклами типа <i>until</i> из-за того, что в них требуется лишняя команда перехода.

</p><p class="code">
<code><b>; for (i = start_i; i &lt; n; i++) &lt;тело цикла&gt;</b>
   mov   edi, start_i		; Начальное значение счётчика
   mov   esi, n			; Конечное значение счётчика
loop_start:
   cmp   edi, esi		; Пока EDI &lt; ESI – выполнять
   je    loop_end
   <i>&lt;тело цикла&gt;</i>
   inc   edi
   jmp   loop_start
loop_end:

<b>; i = start_i; do { &lt;тело цикла&gt; } while (i &lt; n);</b>
   mov edi, start_i
   mov esi, n
loop_start:
   <i>&lt;тело цикла&gt;</i>
   inc   edi
   cmp   edi, esi
   jb    loop_start		; Пока EDI &lt; ESI – выполнять
</code>

</p><p>
Предположим, в цикле должен быть один шаг. Тогда в цикле с предусловием будет выполнено сравнение, тело цикла, безусловный переход к началу цикла, сравнение и переход за цикл. В цикле с постусловием будет выполнено тело цикла, сравнение и нереализованный переход. Таким образом, в цикле с предусловием выполняется одно лишнее сравнение и два реализованных перехода (2 * 3 такта = 6 тактов) вместо одного нереализованного (1 такт). Вроде бы и немного, но если цикл окажется внутри другого цикла, то все эти лишние такты будут повторяться многократно. Кроме того, цикл с постусловием содержит на одну команду меньше.

</p><p>
Конечно, цикл с постусловием всегда выполняется хотя бы один раз, и во многих случаях перед циклом приходится добавлять ещё одну проверку, но в любом случае даже небольшое уменьшение тела цикла всегда оказывается необходимой операцией.


</p><h3 id="a8_2_3">8.2.3. Выполнение цикла задом наперёд</h3>

<p>
Циклы, в которых значение счётчика растёт от единицы или нуля до некоторой величины, можно реализовать вообще без операции сравнения, выполняя цикл в обратном направлении. Флаги меняются не только командой сравнения, но и многими другими. В частности, команда <span class="mnemo">DEC</span> меняет флаги AF, OF, PF, SF и ZF. Команда сравнения кроме этих флагов меняет также флаг CF, но для сравнения с нулём можно обойтись флагами SF и ZF.

</p><p class="code">
<code><b>; Цикл от 10 до 1</b>
   mov   edx, 10
loop_start:
   <i>&lt;тело цикла&gt;</i>
   dec   edx			; Уменьшаем EDX на 1. Если EDX = 0, то ZF = 1
   jnz   loop_start		; Переход если ZF = 0. Когда EDX = 0, ZF = 1, поэтому выходим из цикла

<b>; Цикл от 10 до 0</b>
   mov   edx, 10
loop_start:
   <i>&lt;тело цикла&gt;</i>
   dec   edx			; Уменьшаем EDX на 1. Если EDX = -1, то SF = 1
   jns   loop_start		; Переход если SF = 0. Когда EDX = -1, SF = 1, поэтому выходим из цикла
</code>

</p><p>
Циклы от 0 и от 1 являются, наверное, самыми распространёнными. Конечно, не все циклы можно заставить выполняться в обратном направлении сразу. Например, иногда приходится изменять формат хранения массива данных также на обратный, иногда приходится вносить другие изменения, но в целом, если это возможно, всегда следует стремиться к циклам, выполняющимся задом наперёд.
</p><h3 id="a8_2_4">8.2.4. Разворачивание циклов</h3>

<p>
Для небольших циклов время выполнения проверки условия и перехода на начало цикла может оказаться значительным по сравнению со временем выполнения самого тела цикла. В таких случаях можно вообще не создавать цикл, а просто повторить его тело нужное число раз (разумеется, только в случае, если нам заранее известно это число!). Для очень коротких циклов можно, например, удваивать или утраивать тело цикла, если, конечно, число повторений кратно двум или трём. Кроме того, бывает удобно часть работы сделать в цикле, а часть развернуть.

</p><p class="code">
<code><b>; Цикл от 10 до -1</b>
   mov   edx, 10
loop_start:
   <i>&lt;тело цикла&gt;</i>
   dec   edx
   jns   loop_start		; Выходим из цикла, когда EDX станет равны -1
   <i>&lt;тело цикла&gt;</i>			; Но повторяем тело цикла ещё раз
</code>

</p><p>
Естественно, эти простые методики не перечисляют все возможности оптимизации среднего уровня, более того, они не описывают и десятой доли всех её возможностей. Умение оптимизировать программы нельзя сформулировать в виде набора простых алгоритмов – слишком много существует различных ситуаций, в которых всякий алгоритм оказывается неоптимальным. При решении любой задачи оптимизации приходится пробовать десятки различных небольших изменений, далеко не все из которых оказываются полезными. Именно потому, что оптимизация всегда занимает очень много времени, рекомендуется приступать к ней только после того, как программа окончательно написана.


</p><h2 id="a8_3">8.3. Низкоуровневая оптимизация</h2>

<h3 id="a8_3_1">8.3.1. Основные принципы</h3>

<p>
Так как современные процессоры используют весьма сложный набор команд, большинство операций можно выполнить на низком уровне очень многими способами. При этом иногда оказывается, что наиболее очевидный способ – не самый быстрый. Часто простыми перестановками команд, зная механизм выполнения команд на современных процессорах, можно заставить ту же процедуру выполняться на 50–200% быстрее. Разумеется, переходить к этому уровню оптимизации можно только после того, как текст программы окончательно написан и максимально оптимизирован на среднем уровне.

</p><p>
Перечислим основные рекомендации.

</p><ul>
  <li> Используйте регистр ЕАХ всюду, где возможно. Команды с непосредственным операндом, с операндом – абсолютным адресом переменной и команды <span class="mnemo">XCHG</span> с регистрами занимают на один байт меньше, если другой операнд – регистр ЕАХ.
  </li><li> Если к переменной в памяти, адресуемой со смещением, выполняется несколько обращений – загрузите её в регистр.
  </li><li> Не используйте сложные команды – <span class="mnemo">ENTER</span>, <span class="mnemo">LEAVE</span>, <span class="mnemo">LOOP</span>, строковые команды, если аналогичное действие можно выполнить небольшой последовательностью простых команд.
  </li><li> Не используйте умножение или деление на константу – его можно заменить другими командами (см. <a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#a6_3">раздел 6.3</a>).
  </li><li> Старайтесь программировать условия и переходы так, чтобы переход выполнялся по менее вероятному событию.
  </li><li> Следующее эмпирическое правило, относящееся к переходам и вызовам, очень простое: избавляться от них везде, где только можно. Для этого организуйте программу так, чтобы она исполнялась прямым, последовательным образом, с минимальным числом точек принятия решения. В результате очередь команд будет почти всегда заполнена, а вашу программу будет легче читать, сопровождать и отлаживать. Процедуры, особенно небольшие, нужно не вызывать, а встраивать. Это, конечно, увеличивает размер программы, но даёт существенный выигрыш во времени её исполнения.
  </li><li> Используйте короткую форму команды <span class="mnemo">JMP</span>, где возможно (<code>jmp short &lt;метка&gt;</code>).
  </li><li> Команда <span class="mnemo">LEA</span> быстро выполняется и имеет много неожиданных применений (см. <a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#a8_3_2">раздел 8.3.2</a>).
  </li><li> Многие одиночные команды, как это ни странно, выполняются дольше, чем две или три команды, приводящие к тому же результату. Это может быть связано с различными особенностями выполнения команд, в том числе, с возможностью/невозможность попарного выполнения команд в разных конвейерах (см. <a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#a8_3_3">раздел 8.3.3</a>).
  </li><li> Старайтесь выравнивать данные и метки по адресам, кратным 2/4/8/16 (см. <a href="http://natalia.appmat.ru/c&amp;c++/assembler.html#a8_3_4">раздел 8.3.4</a>).
  </li><li> Если команда обращается к 32-битному регистру, например ЕАХ, сразу после команды, выполнявшей запись в соответствующий частичный регистр (АХ, AL, АН), может происходить пауза в один или несколько тактов.
</li></ul>


<h3 id="a8_3_2">8.3.2. Использование команды <span class="mnemo">LEA</span></h3>

<ul>
  <li> Команда <span class="mnemo">LEA</span> может использоваться для трёхоперандного сложения (но только сложения, а не вычитания).
</li></ul>

<p class="code">
<code>lea   eax, [ebx + edx]
</code>

</p><ul>
  <li> Команда <span class="mnemo">LEA</span> может использоваться для сложения значения регистра с константой или вычитания константы из значения регистра. В данном случае вычитание возможно, т.к. оно рассматривается как сложение с отрицательной константой. Результат может быть помещён в тот же или другой регистр (кроме регистра ESP). Такой способ используется для сохранения флагов, т.к. команда <span class="mnemo">LEA</span>, в отличие от команд <span class="mnemo">ADD</span>, <span class="mnemo">SUB</span>, <span class="mnemo">INC</span> и <span class="mnemo">DEC</span>, не меняет флаги.
</li></ul>

<p class="code">
<code>lea   eax, [eax + 1]			; Сохраняем флаги
lea   eax, [ebx – 4]
</code>

</p><ul>
  <li> Команда <span class="mnemo">LEA</span> может использоваться для быстрого умножения на константы 2, 3, 4, 5, 7(?), 8, 9. Адрес, загружаемый командой <span class="mnemo">LEA</span>, может быть суммой двух регистров, один из которых может быть умножен на константу 2, 4 или 8. Поэтому комбинируя умножение и сложение можно получить вышеперечисленные константы. Третье слагаемое может быть константой.
</li></ul>

<p class="code">
<code>lea   eax, [eax * 4 + eax]		; EAX = EAX * 5
lea   eax, [ebx * 8 + ecx – 32]
</code>


</p><h3 id="a8_3_3">8.3.3. Замена команд</h3>


<ul>
  <li> Вместо команды <span class="mnemo">AND</span> лучше использовать команду TEST, если нужен не результат, а проверка. Команда TEST лучше спаривается. Команда TEST также может быть использована для проверки на равенство нулю.
</li></ul>

<p class="code">
<code>test  eax, eax
jz    &lt;метка&gt;				; Переход, если EAX = 0
</code>

</p><ul>
  <li> Если за командой <span class="mnemo">CALL</span> сразу же следует команда <span class="mnemo">RET</span>, замените эти команды командой <span class="mnemo">JMP</span>. Вызываемая процедура осуществит возврат по адресу возврата, переданному вызывающей процедуре.
</li></ul>

<p class="code">
<code>call dest					jmp dest
ret
</code>

</p><ul>
  <li> Команду <span class="mnemo">CBW</span> можно заменить засылкой нуля, если расширяемое число положительное. Команду <span class="mnemo">CDQ</span> можно заменить засылкой нуля, если расширяемое число положительное, или парой команд <span class="mnemo">MOV</span>&nbsp;+&nbsp;<span class="mnemo">SAR</span>, если знак расширяемого числа не известен. Недостаток – команды <span class="mnemo">XOR</span> и <span class="mnemo">SAR</span> меняют флаги.
</li></ul>

<p class="code">
<code>cdq						xor   edx, edx

cdq						mov   edx, eax
						sar   edx, 31
</code>

</p><ul>
  <li> Вместо команд инкремента и декремента можно использовать команду <span class="mnemo">LEA</span>.
  </li><li> Сложение и вычитание с константой можно заменить командой <span class="mnemo">LEA</span>.
  </li><li> Вместо умножения и деления на степень числа 2 используйте сдвиги.
  </li><li> Умножение и деление на константу можно заменить командой <span class="mnemo">LEA</span> или сочетанием команд сдвига и команд сложения и вычитания.
  </li><li> Деление на константу можно заменить умножением на константу.
  </li><li> Обнуление регистров производится с помощью команды <span class="mnemo">XOR</span>.
</li></ul>

<p class="code">
<code>xor   eax, eax				; EAX = 0 при любом значении EAX, которое было до этой команды
</code>

</p><ul>
  <li> Не используйте команду <span class="mnemo">MOVZX</span> для чтения байта – это требует 3 тактов для выполнения. Заменой может служить такая пара команд, выполняющаяся за 2 такта:
</li></ul>

<p class="code">
<code>xor   еах, еах
mov   al, &lt;источник&gt;
</code>

</p><ul>
  <li> Засылку непосредственного операнда в ячейку памяти можно производить через регистр – такие команды лучше спариваются.
</li></ul>

<p class="code">
<code>mov   x, 1					mov   eax, 1
						mov   x, eax
mov   [ebx], 1					mov   eax, 1
						mov   [ebx], eax
</code>

</p><ul>
  <li> Аналогично команды <span class="mnemo">PUSH</span> и <span class="mnemo">POP</span>, работающие с ячейкой памяти, можно заменить парой команд <span class="mnemo">MOV</span>&nbsp;+&nbsp;<span class="mnemo">PUSH</span> или <span class="mnemo">POP</span>&nbsp;+&nbsp;<span class="mnemo">MOV</span>.
</li></ul>

<p class="code">
<code>push  x						mov   eax, x
						push  eax
pop   x						pop   eax
						mov   x, eax
</code>


</p><h3 id="a8_3_4">8.3.4. Выравнивание</h3>

<ul>
  <li> 80-битные данные должны быть выравнены по 16-байтным границам (то есть четыре младших бита адреса должны быть равны нулю).
  </li><li> Восьмибайтные данные должны быть выравнены по восьмибайтным границам (то есть три младших бита адреса должны быть равны нулю).
  </li><li> Четырёхбайтные данные должны быть выравнены по границе двойного слова (то есть два младших бита адреса должны быть равны нулю).
  </li><li> Двухбайтные данные должны быть выравнены по границе слова.
  </li><li> Метки для переходов, особенно метки, отмечающие начало цикла, должны быть выравнены по 16-байтным границам.
</li></ul>

<p>
Каждое невыравненное обращение к данным означает потерю тактов процессора.

</p><p>
Для выравнивания данных и кода используется директива <span class="mnemo">ALIGN</span>:

</p><p class="code">
<code><span class="mnemo">ALIGN</span> &lt;число&gt;
</code>

</p><p>
Число должно быть степенью двойки. Данные и команда, расположенные после директивы <span class="mnemo">ALIGN</span>, будут размещены по адресу, кратному указанному числу.

</p></section>

<section id="a9">
<h1>9. Примеры</h1>

<ol style="padding-left: 15pt">
  <li> <b>Процедура вычисления наибольшего общего делителя двух беззнаковых чисел.</b> Для нахождения НОД используется алгоритм Евклида: пока числа не равны, надо вычитать из большего числа меньшее. Процедура получает параметры через регистры EAX и EDX и возвращает результат через регистр EAX.
</li></ol>

<p class="code">
<code>NOD proc
   N1: cmp   eax, edx			; Сравниваем числа
       je    N3				; Если числа равны, завершаем работу процедуры
       ja    N2				; Если первое число больше, обходим обмен
					; Поскольку команды перехода не меняют флаги, оба перехода
					; выполняются или не выполняются по результатам одного сравнения
       xchg  eax, edx			; Если первое число было меньше, выполняем обмен
   N2: sub   eax, edx			; Вычитаем из большего числа меньшее
       jmp   N1				; Переход к началу цикла
   N3: ret
NOD endp
</code>

</p><ol style="padding-left: 15pt" start="2">
  <li> <b>Ввод и вывод в консольном приложении.</b> В программе используются следующие функции Win32 API.
</li></ol>

<ul style="list-style-type: disc">
  <li> <i>SetConsoleTitle</i> – меняет заголовок окна консоли. Получает один параметр – указатель на строку, которая будет выведена в заголовке. Строка должна заканчиваться нулём.
  </li><li> <i>GetStrHandle</i> – возвращает идентификатор <i>устройства ввода</i>, <i>устройства вывода</i> или <i>устройства отчёта об ошибках</i>. Для консольного приложения всё три устройства являются консолью, но идентификаторы будут разными. Функция получает один параметр – указание, идентификатор какого устройства нужно вернуть. Чтобы получить идентификатор устройства ввода, надо передать функции число -10, чтобы получить идентификатор устройства вывода – число -11, а чтобы получить идентификатор устройства отчёта об ошибках – число -12. Функция возвращает требуемый идентификатор через регистр EAX.
  </li><li> <i>WriteConsole</i> – выводит строку в консоль. Получает следующие параметры – идентификатор устройства вывода, адрес выводимой строки, количество символов для вывода, адрес переменной, куда будет записано количество выведенных символов, зарезервированный указатель.
  </li><li> <i>ReadConsole</i> – вводит строку из консоли. Получает следующие параметры – идентификатор устройства ввода, адрес памяти, куда будет записана введённая строка, максимальное количество читаемых символов, адрес переменной, куда будет записано реальное количество введённых символов, зарезервированный указатель.
</li></ul>

<p>
Не забывайте, что параметры кладутся в стек, начиная с последнего, и что введённая строка всегда будет содержать в конце символы с кодами 13 и 10, которые появляются при нажатии на клавишу <i>ВВОД</i> (без чего, однако, ввод не завершится).

</p><p class="code">
<code>.686
.model flat, c
option casemap: none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib

.data
  str     db 256 dup(0)
  hStdIn  dd 0
  hStdOut dd 0
  slength dd 0

.const
  sConsoleTitle db 'Input and Output',0		; Заголовок окна консоли. Заканчивается нулём
  prompt db 'Input a string', 13,10		; Приглашение для ввода. Символы с кодами 13 и 10 
						; обеспечивают перевод курсора на следующую строку
  
STD_INPUT_HANDLE  equ -10d			; Определяем символические имена для констант,
STD_OUTPUT_HANDLE equ -11d			; указывающих требуемое устройство

.code
program:
  ; Вывод заголовка консоли
      push  offset sConsoleTitle		; Кладём в стек адрес начала строки заголовка консоли
      call  SetConsoleTitle			; Вызываем функцию

   ; Получаем идентификатор устройства ввода
      push  STD_INPUT_HANDLE			; Кладём в стек параметр функции GetStdHandle
      call  GetStdHandle			; Вызываем функцию
      mov   hStdIn, eax				; Сохраняем полученный идентификатор

 ; Получаем идентификатор устройства вывода
      push  STD_OUTPUT_HANDLE
      call  GetStdHandle
      mov   hStdOut, eax

  ; Выводим приглашение
      push  0					; Зарезервированный параметр, в стек кладём 0
      push  0					; Указатель на переменную для записи количества выведенных символов,
						; в данном случае не нужен, поэтому в стек кладём 0
      push  10h					; Количество выводимых символов
      push  offset prompt			; Адрес выводимой строки
      push  hStdOut				; Идентификатор устройства вывода
      call  WriteConsole			; Вызываем функцию

  ; Вводим строку
      push  0					; Зарезервированный параметр, в стек кладём 0
      push  offset slength			; Адрес переменной, куда будет записано количество введённых символов
      push  256					; Максимальное количество вводимых символов
      push  offset str				; Адрес для записи введённой строки
      push  hStdIn				; Идентификатор устройства ввода
      call  ReadConsole				; Вызываем функцию

  ; Выводим строку
      push  0
      push  0
      push  slength
      push  offset str
      push  hStdOut
      call  WriteConsole

  ; Задержка
      push  1800h
      call  Sleep
      
      push  0
      call  ExitProcess
end program
</code>

</p><ol style="padding-left: 15pt" start="3">
  <li> <b>Процедура ввода целого числа в 16-ричной системе счисления.</b> Процедура предназначена для использования в консольном приложении и предполагает, что идентификатор устройства ввода был получен основной программой и сохранён в переменной <i>hStdIn</i>.
</li></ol>

<p class="code">
<code>InputNumber proc
      push  ebp					; Сохраняем в стеке значение регистра EBP
      mov   ebp, esp				; Заносим в регистр EBP текущее значение вершины стека
      sub   esp, 16				; Резервируем 16 байт. Вводимая строка может содержать до 8 цифр.
						; 2 байта требуются для символов с кодами 13 и 10. Итого 10 байт.
						; 4 байта нужно для целочисленной переменной, куда будет записываться количество
						; введённых символов. Итого 14 байт. Но выделим 16 байт, т.е. 4 двойных слова
      push  ebx					; Сохраняем значения важных регистров
      push  esi
  
  ; Вводим строку
      push  0
      lea   eax, [ebp - 16]			; 4 байта по адресу [EBP&nbsp;–&nbsp;16] предназначены для хранения количества введённых символов
      push  eax
      push  10d
      lea   eax, [ebp - 12]			; По адресу [EBP&nbsp;–&nbsp;12] начинается память для вводимой строки
      push  eax
      push  hStdIn
      call  ReadConsole

  ; Преобразуем строку в число
      xor   eax, eax				; Обнуляем регистр EAX <b>...</b>
      xor   ebx, ebx				; <b>...</b> и регистр EBX
      mov   ecx, [ebp - 16]			; Заносим в регистр ECX количество введённых символов
      sub   ecx, 2				; Символы с кодами 13 и 10 обрабатывать не надо
      lea   esi, [ebp - 12]			; Заносим в регистр ESI адрес начала строки

      test  ecx, ecx				; Используем команду TEST для сравнения с нулём
      jz    L2					; Если ECX = 0, то завершаем работу процедуры
  L1: mov   bl, [esi]				; Заносим в регистр BL текущий символ (три старших байта EBX
						; содержат 0, т.к. ранее была команда <span class="mnemo">XOR</span> EBX, EBX)
      lea   edx, [ebx - '0']			; Заносим в регистр EDX разность между кодом текущего символа и кодом символа '0'
      cmp   edx, 9				; Сравниваем значение в регистре EDX с 9
      ja    M1					; Если выше, то переходим к следующему сравнению
      sub   bl, '0'				; Иначе получаем число из кода символа
      jmp   M3					; Переходим к действиям, учитывающим текущую цифру
  M1: lea   edx, [ebx - 'a']			; Заносим в регистр EDX разность между кодом текущего символа и кодом символа 'a'
      cmp   edx, 'f' - 'a'			; Сравниваем значение в регистре EDX с 5
      ja    M2					; Если выше, то переходим к следующему сравнению
      sub   bl, 'a' - 10d			; Иначе получаем число из кода символа
      jmp   M3					; Переходим к действиям, учитывающим текущую цифру
  M2: lea   edx, [ebx - 'A'] 			; Заносим в регистр EDX разность между кодом текущего символа и кодом символа 'A'
      cmp   edx, 'F' - 'A'			; Сравниваем значение в регистре EDX с 5
      ja    L2					; Если выше, то завершаем процедуру. Результат не определён,
						; т.к. был введён некорректный символ
      sub   bl, 'A' - 10d			; Иначе получаем число из кода символа
  M3: sal   eax, 4				; Умножаем EAX на 16
      add   eax, ebx				; Прибавляем текущую цифру
      inc   esi					; Переходим к следующему символу
      dec   ecx					; Уменьшаем ECX на 1
      jnz   L1					; Если ECX не равно 0, продолжаем цикл

  L2: pop   esi					; Восстанавливаем значения использовавшихся регистров
      pop   ebx
      mov   esp, ebp				; Освобождаем стек
      pop   ebp					; Восстанавливаем значение регистра EBP
      ret
InputNumber endp
</code>

</p><ol style="padding-left: 15pt" start="4">
  <li> <b>Процедура вывода числа в 16-ричной системе счисления.</b> Процедура получает один параметр – выводимое число. Для вывода всегда формируется строка из 8-ми шестнадцатеричных цифр с лидирующими нулями. Поскольку количество символов заранее известно, они будут сразу же записываться в строку с конца, и инвертировать строку не придётся. Процедура предназначена для использования в консольном приложении и предполагает, что идентификатор устройства ввода был получен основной программой и сохранён в переменной <i>hStdOut</i>.
</li></ol>

<p class="code">
<code>digits  db '0123456789abcdef'			; Массив шестнадцатеричных цифр

OutputNumber proc
      push  ebp					; Сохраняем в стеке значение регистра EBP
      mov   ebp, esp				; Заносим в регистр EBP текущее значение вершины стека
      sub   esp, 12				; Выделяем в стеке место под формируемую строку
      push  esi
      
  ; Преобразуем число в строку
      mov   eax, [ebp + 8]			; Заносим в регистр EAX переданный параметр
      mov   ecx, 8				; Заносим в регистр ECX количество символов строки
      mov   byte ptr [ebp - 1], 10		; Добавляем в конец строки символы с кодами 13 и 10 для перевода курсора
      mov   byte ptr [ebp - 2], 13
      lea   esi, [ebp - 3]			; Начиная с адреса [EBP&nbsp;-&nbsp;3] будут заносится цифры
  L3: mov   edx, eax				; Копируем значение регистра EAX в регистр EDX
      and   edx, 1111b				; Получаем остаток от деления на 16
      shr   eax, 4				; Делим исходное число на 16
      mov   dl, digits[edx]			; По полученному остатку от деления берём цифру <b>...</b>
      mov   [esi], dl				; <b>...</b> и записываем её в строку
      dec   esi					; Уменьшаем адрес, т.к. строка формируется с конца
      dec   ecx					; Уменьшаем ECX на 1
      jnz   L3					; Если ECX не равно 0, продолжаем цикл
      
  ; Выводим строку
      inc   esi					; Регистр ESI указывает на начало строки
      push  0
      push  0
      push  10
      push  esi
      push  hStdOut
      call  WriteConsole

      pop   esi
      mov   esp, ebp				; Освобождаем стек
      pop   ebp					; Восстанавливаем значение регистра EBP
      ret   4					; Удаляем из стека переданный параметр и возвращаемся
OutputNumber endp
</code>

</p><ol style="padding-left: 15pt" start="5">
  <li> <b>Функция, находящая в одномерном массиве x сумму значений <i>f</i>(<i>x</i>[<i>i</i>]),</b> где <i>f</i> – некоторая функция одного целочисленного аргумента, адрес которой передаётся через параметры. Функции используют соглашение о вызовах <i>cdecl</i>.
</li></ol>

<p class="code">
<code>Sum proc
      push  ebp
      mov   ebp, esp
      push  esi
      push  edi

      mov   ecx, [ebp + 8]			; Заносим в ECX первый параметр – количество элементов массива
      mov   esi, [ebp + 12]			; Заносим в ESI второй параметр – адрес начала массива
      mov   edi, [ebp + 16]			; Заносим в EDI третий параметр – адрес функции
      xor   edx, edx				; Обнуляем регистр EDX
  L:  push  [esi]				; Кладём в стек элемент массива
      call  edi					; Вызываем функцию, адрес которой находится в регистре EDI
      add   esp, 4				; Освобождаем стек
      add   edx, eax				; Прибавляем результат функции к общей сумме
      add   esi, 4				; Переходим к следующему элементу массива
      dec   ecx					; Уменьшаем значение регистра ECX на 1
      jnz   L					; Если ECX не равно 0, продолжаем цикл
      mov   eax, edx				; Записываем полученную сумму в регистр EAX,
						; через который должен возвращаться результат функции
      pop   edi
      pop   esi
      mov   esp, ebp
      pop   ebp
      ret
Sum endp

Sqr proc
      mov   eax, [esp + 4]
      imul  eax
      ret
Sqr endp

Negation proc
      mov   eax, [esp + 4]
      neg   eax
      ret
Negation endp
</code>

</p><p>
Для вызова функции <i>Sum</i> будет использовать следующая последовательность команд.

</p><p class="code">
<code>      push  Sqr
      push  offset a
      push  na
      call  Sum
      add   esp, 12
      mov   sa, eax

      push  Negation
      push  offset a
      push  na
      call  Sum
      add   esp, 12
      mov   sa, eax
</code>

</p><ol style="padding-left: 15pt" start="6">
  <li> <b>Процедура, проверяющая сбалансированность круглых и квадратных скобок в строке.</b> Строка должна заканчиваться нулём. Для проверки сбалансированности открывающие скобки будем класть в стек, а при нахождении в строке закрывающей скобки будем извлекать из стека последнюю положенную туда открывающую скобку и проверять, что она соответствует закрывающей скобке. Будем считать, что скобок в тексте меньше, чем других символов, поэтому после сравнения делаем переход «если равно», считая, что это событие менее вероятно. При любом выходе из процедуры нужно очистить стек. Поскольку мы не можем заранее знать, сколько скобок будет туда положено и сколько извлечено, восстановление значения регистра ESP можно сделать только с помощью регистра EBP. Процедура возвращает значение через регистр EAX: если скобки сбалансированы, регистр EAX будет содержать значение <i>истина</i> (-1), в противном случае регистр EAX будет содержать значение <i>ложь</i> (0).
</li></ol>

<p class="code">
<code>Brackets proc
      push  ebx				; Сохраняем регистры
      push  ebp
      mov   ebp, esp			; Сохраняем начальное значение регистра ESP

      mov   ebx, [ebp + 12]		; Заносим в регистр EBX адрес начала строки
      mov   eax, -1			; Заносим в регистр EAX предварительное значение результата
      xor   edx, edx			; Обнуляем регистр EDX
  L1: mov   dl, [ebx]			; Заносим в регистр DL очередной символ
      test  edx, edx			; Проверяем значение в регистре EDX
      jz    E1				; Если EDX = 0, выходим из цикла
      inc   ebx				; Меняем адрес символа
      cmp   dl, '('			; Сравниваем символ с открывающей круглой скобкой
      je    L2				; Если равно, <b>...</b>
      cmp   dl, '['			; Сравниваем символ с открывающей квадратной скобкой
      je    L2				; Если равно, <b>...</b>
      cmp   dl, ')'			; Сравниваем символ с закрывающей круглой скобкой
      je    L3				; Если равно, переходим к сравнению со скобкой из стека
      cmp   dl, ']'			; Сравниваем символ с закрывающей квадратной скобкой
      je    L4				; Если равно, переходим к сравнению с другой скобкой из стека
      jmp   L1				; Если символ – не скобка, возвращаемся к началу цикла
  L2: push  dx				; <b>...</b> заносим открывающую скобку в стек (один байт записать в стек нельзя)
      jmp   L1				; Возвращаемся к началу цикла
  L3: cmp   ebp, esp			; Если была закрывающая скобка, прежде всего проверяем, есть ли скобки в стеке –
					; если мы положили что-то в стек, значение регистра ESP будет отличаться от регистра EBP
      je    E2				; Если значения регистров равны, выходим из процедуры
      pop   cx				; Извлекаем из стека последнюю открывающую скобку
      cmp   cl, '('			; Сравниваем
      jne   E2				; Если скобки не равны, выходим из процедуры
      jmp   L1				; Иначе возвращаемся к началу цикла
  L4: cmp   ebp, esp			; При нахождении закрывающей квадратной скобки,
      je    E2				; выполняем те же действия, что и при нахождении закрывающей круглой скобки,
      pop   cx				; только скобку из стека сравниваем с другим значением
      cmp   cl, '['			; Дублирование сделано для того, чтобы уменьшить 
      jne   E2				; количество переходов
      jmp   L1

  E1: cmp   ebp, esp			; При достижении конца строки, сравниваем регистры ESP и EBP
      je    E3				; Если значения равны, обходим обнуление регистра EAX
  E2: xor   eax, eax			; Если была несбалансированность, обнуляем регистр EAX
  E3: mov   esp, ebp			; Восстанавливаем значение регистра ESP
      pop   ebp
      pop   ebx
      ret
Brackets endp
</code>

</p></section>

<footer id="note">
<p id="nota1" class="nota">
<sup>1</sup>
В защищённом режиме программе выделяется один сегмент размером 4&nbsp;Гб для кода и один сегмент размером 4&nbsp;Гб для данных (физически они обычно совпадают). Виртуальный адрес состоит из 16-битного значения, хранящегося в сегментном регистре, и 32-битного смещения. Однако преобразование виртуального адреса в физический осуществляется не путём сложения, а по более сложной схеме. Сначала процессор преобразует виртуальный адрес в линейный. При этом он обращается к таблицам дескрипторов, которые заранее строятся операционной системой. На втором этапе по линейному адресу определяется физический. В этом преобразовании участвует другой набор системных таблиц – таблицы страничной трансляции, которые также составляются операционной системой. Оба набора таблиц могут динамически меняться, обеспечивая максимальное использование оперативной памяти.
  
</p><p class="nota">
В сегментные регистры записываются не адреса сегментов, а селекторы, которые представляют собой номера ячеек специальной таблицы, содержащей дескрипторы сегментов программ. Каждый дескриптор хранит все характеристики, необходимые для обслуживания сегмента: базовый линейный адрес сегмента, границу сегмента (номер последнего байта), а также атрибуты сегмента, определяющие его свойства. Процессор с помощью селектора определяет индекс дескриптора адресуемого сегмента, извлекает из него базовый линейный 32-битный адрес сегмента и, сложив его с 32-битным смещением, получает линейный адрес адресуемой ячейки памяти. Получив линейный адрес адресуемого байта, процессор с помощью таблиц трансляции преобразует его в 32-битный физический адрес. Этот адрес зависит от объёма оперативной памяти, установленной на компьютере.
  
</p><p class="nota">
В 32-битной модели Windows предоставляет всем запущенным приложениям один и тот же селектор для сегмента кода и один и тот же селектор для сегмента данных. Базы обоих сегментов равны 0, а границы – FFFFFFFF. Другими слова, каждому приложению как бы предоставляется всё линейное пространство. Поскольку базовые линейные адреса сегментов программы равны 0, виртуальные смещения, с которыми работают приложения, совпадают с линейными адресами. Другими словами, плоское виртуальное адресное пространство программы совпадает с плоским линейным адресным пространством. При этом все приложения используют один и тот же диапазон линейных адресов. Для того чтобы при одинаковых линейных адресах приложения занимали различные участки физической памяти и не затирали друг друга, Windows при смене приложения изменяет таблицы страничной трансляции, с помощью которых как раз и происходит преобразование линейных адресов в физические.
  
</p><p id="nota2" class="nota">
<sup>2</sup>
Если говорить точнее, то относительный адрес перехода отсчитывается не от самой команды перехода, а от следующей за ней команды. Дело в том, что выполнение любой команды начинается с засылки в регистр EIP адреса следующей по порядку команды и только затем выполняется собственно команда. Поэтому в команде перехода относительный адрес будет прибавляться к значению регистра EIP, которое уже указывает на следующую команду, а потому от этой следующей команды и приходится отсчитывать относительный адрес перехода. Однако, в любом случае, программисту нет необходимости самому высчитывать относительный адрес перехода, это делает компилятор языка ассемблера.
  
</p><p id="nota3" class="nota">
<sup>3</sup>
Компьютерная программа в целом или её отдельная процедура называется реентерабельной (от англ. <i>reentrant</i> – повторно входимый), если она разработана таким образом, что одна и та же копия инструкций программы в памяти может быть совместно использована несколькими пользователями или процессами. При этом второй пользователь может вызвать реентерабельный код до того, как с ним завершит работу первый пользователь и это как минимум не должно привести к ошибке, а в лучшем случае не должно вызвать потери вычислений (то есть не должно появиться необходимости выполнять уже выполненные фрагменты кода).
  
</p><p class="nota">
Для обеспечения реентерабельности необходимо выполнение нескольких условий:

</p><ul>
  <li style="font-size: 12pt"> никакая часть вызываемого кода не должна модифицироваться;
  </li><li style="font-size: 12pt"> вызываемая процедура не должна сохранять информацию между вызовами;
  </li><li style="font-size: 12pt"> если процедура изменяет какие-либо данные, то они должны быть уникальными для каждого пользователя;
  </li><li style="font-size: 12pt"> процедура не должна возвращать указатели на объекты, общие для разных пользователей.
</li></ul>

<p class="nota">
В общем случае, для обеспечения реентерабельности необходимо, чтобы вызывающий процесс или функция каждый раз передавал вызываемому процессу все необходимые данные. Таким образом, функция, которая зависит только от своих параметров, не использует глобальные и статические переменные и вызывает только реентерабельные функции, будет реентерабельной. Если функция использует глобальные или статические переменные, необходимо обеспечить, чтобы каждый пользователь хранил свою локальную копию этих переменных.
</p></footer>


<footer><hr>  <a href="http://natalia.appmat.ru/c&amp;c++/index.php?sezione=lezioni"> Содержание </a>

<!--
<a href = "http://jigsaw.w3.org/css-validator/check/referer"> <img id = "css" src = "Images/vcss-blue.gif" alt = "Правильный CSS!" /></a>
-->

</footer>




</body></html>